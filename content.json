{"meta":{"title":"GyCalcc","subtitle":null,"description":"好少年光芒万丈","author":"GyCalcc","url":""},"pages":[{"title":"about","date":"2019-10-10T14:14:36.000Z","updated":"2019-10-25T10:28:30.006Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のCalcc] 与&nbsp; Calcc&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-10-10T13:32:48.000Z","updated":"2019-10-25T10:28:56.223Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2019-10-10T15:13:35.000Z","updated":"2019-10-25T10:29:14.208Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2019-10-10T15:13:48.000Z","updated":"2019-10-25T10:29:29.110Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-10-10T13:47:59.000Z","updated":"2019-10-25T10:30:00.132Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2019-10-10T15:13:05.000Z","updated":"2019-10-25T10:29:46.277Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"music","date":"2019-10-10T15:14:28.000Z","updated":"2019-10-25T10:30:28.687Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2019-10-10T15:11:06.000Z","updated":"2019-10-25T10:30:15.702Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2019-10-10T14:14:16.000Z","updated":"2019-10-25T10:30:58.557Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2019-10-10T15:09:03.000Z","updated":"2019-10-25T10:30:45.501Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-25T10:31:12.607Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2019-10-10T15:14:38.000Z","updated":"2019-10-13T07:08:39.566Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2019-10-10 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2019-10-10 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"wechat1","slug":"wechat1","date":"2020-03-07T09:24:17.000Z","updated":"2020-03-07T10:02:49.938Z","comments":true,"path":"2020/03/07/wechat1/","link":"","permalink":"/2020/03/07/wechat1/","excerpt":"","text":"微信开发微信这个软件，提供了聊天、支付、分享、收藏等各种功能，同时用户基数庞大；微信对外开放了很多接口和能力，程序员基于这些功能进行的二次开发，叫做微信开发； 微信开放平台微信开放平台是微信对外提供微信开放接口的一个平台，这些开放出来的微信接口，供第三方的网站或App使用；平台登录地址:https://open.weixin.qq.com 小程序中的组件和API组件组件是视图层的基本组成单元，它自带一些功能与微信风格一致的样式。一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。 这里可以在微信中搜索“小程序示例”便可以在手机上查询相关组件 APIAPI（Application Programming Interface，应用程序编程接口）是一些预先定义的函数。目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力。通过API，开发人员无需访问程序的源码，或理解其内部工作机制的细节。微信同样提供了对外访问的 API ，这些 API 是微信开放给小程序开发者使用的能力。例如：微信扫码、获取用户的地理位置、微信支付等等。丰富的微信 API 和庞大的用户群体，是小程序开发的魅力所在！ API的分类 事件监听API特点：这类 API 以 on 开头，用来监听某个事件是否触发举例：wx.onNetworkStatusChange(function callback) // 当网络状态更改时触发此事件 同步API特点1：以 Sync 结尾的 API 都是同步 API特点2：同步 API 的执行结果，可以通过函数返回值直接获取举例：var batteryInfo = wx.getBatteryInfoSync() // 获取电池信息 异步API特点：通常需要指定回调函数接收调用的结果；小程序中，大多数 API 都是异步 API举例：wx.request(Object object) // 发起 HTTPS 网络请求 小程序开发在开发小程序之前需要以下几步操作 在微信公众平台注册账号，并对账号进行设置 下载并安装微信开发者工具，下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 创建小程序项目 打开小程序开发者工具，用微信扫码登录开发者工具 点击左侧菜单中的小程序选项 点击+号新建小程序项目 填写项目名称 选择项目存放路径（必须选择空目录） 填写AppID 点击新建按钮 小程序的项目结构├── pages ······································ 【目录】存放所有的小程序页面 │ │── index ······································· 【目录】index 页面 │ │ ├── index.wxml ··························· 【文件】 index 页面的结构 │ │ ├── index.js ·································· 【文件】 index 页面的逻辑 │ │ ├── index.json ····························· 【文件】 index 页面的配置 │ │ └── index.wxss ···························· 【文件】 index 页面的样式 │ └── logs ·········································· 【目录】 logs 页面 │ ├── logs.wxml ································【文件】 logs 页面的结构 │ └── logs.js ·······································【文件】 logs 页面的逻辑 └── utils ········································ 【目录】 存放小程序中用到的工具函数 ├── app.js ···································· 【文件】 小程序逻辑 ├── app.json ······························· 【文件】 小程序的公共配置 ├── app.wxss ······························ 【文件】小程序公共样式表 ├── project.config.json ··········· 【文件】 开发工具配置文件 小程序页面与vue组件对比 每个.vue组件，是由 template 模板结构、script 行为逻辑、 style 样式3个部分组成的 每个小程序的页面，是由 .wxml 结构、.js 逻辑、.json 配置、.wxss 样式表 这4个文件组成的 小程序页面中每个组成部分的作用 .wxml : 用来描述当前这个页面的结构，同时提供了类似于Vue中指令的语法 .js : 用来定义当前页面中用到的数据、交互逻辑和响应用户的操作 .json : 用来定义当前页面的个性化配置，例如，为每个页面单独配置顶部颜色、是否允许下拉刷新等 .wxss : 用来定义样式来美化当前的页面","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"react基础学习（二）","slug":"react2","date":"2020-03-07T09:04:30.000Z","updated":"2020-03-07T09:19:43.623Z","comments":true,"path":"2020/03/07/react2/","link":"","permalink":"/2020/03/07/react2/","excerpt":"","text":"React组件表单处理受控组件 HTML中的表单元素是可输入的，也就是有自己的可变状态 而React中可变状态通常保存在state中，并且只能通过setState() 方法来修改 React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值 受控组件：值受到react控制的表单元素 使用步骤 在state中添加一个状态，作为表单元素的value值 给表单元素绑定change事件，将表单元素的值设置为state的值 示例democlass App extends React.Component { state = { txt : &#39;&#39; } inputChange=(e)=&gt;{ this.setState({ txt: e.target.value }) } render(){ console.log(this.state); return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.txt} onChange={this.inputChange}/&gt; &lt;/div&gt; ) } } ReactDOM.render(&lt;App /&gt;,document.getElementById(&#39;root&#39;)) 多表单元素优化 问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐 优化：使用一个事件处理程序同时处理多个表单元素 步骤 给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的） 根据表单内容来获取对应值 在change事件处理程序中通过 [name] 来修改对应的state 示例democlass Haaa extends React.Component { state={ txt:&#39;&#39;, isChecked:false } inputChange = (e)=&gt;{ let target = e.target; let value = target.type == &#39;checkbox&#39; ? target.checked : target.value; this.setState({ [target.name]: value }) } render() { console.log(this.state.txt); console.log(this.state.isChecked); return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={this.state.txt} name=&quot;txt&quot; onChange={this.inputChange}/&gt; &lt;input type=&quot;checkbox&quot; value={this.state.isChecked} name=&quot;isChecked&quot; onChange={this.inputChange}/&gt; &lt;/div&gt; ) } } 非受控组件 (不常使用) 说明：借助于ref，使用元素DOM方式获取表单元素值 ref的作用：获取DOM或者组件 使用步骤 调用 React.createRef() 方法创建ref对象 将创建好的 ref 对象添加到文本框中 通过ref对象获取到文本框的值 class App extends React.Component { constructor(){ super() //创建 ref this.txtRef = React.createRef() } // 获取文本框的值 getTxt =() =&gt; { console.log(this.txtRef.current.value) } render(){ return ( &lt;div&gt; &lt;input type =&quot;text&quot; ref={this.txtRef} /&gt; &lt;button onClick ={this.getTxt}&gt;获取值&lt;/button&gt; &lt;/div&gt; ) } }","categories":[{"name":"web 技术","slug":"web-技术","permalink":"/categories/web-技术/"}],"tags":[],"keywords":[{"name":"web 技术","slug":"web-技术","permalink":"/categories/web-技术/"}]},{"title":"react基础学习（一）","slug":"react1","date":"2020-03-06T10:30:47.000Z","updated":"2020-03-07T09:19:28.784Z","comments":true,"path":"2020/03/06/react1/","link":"","permalink":"/2020/03/06/react1/","excerpt":"","text":"什么是ReactReact是一个用于构建用户界面的javaScript库；主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）；用来架设 Instagram 的网站，并于 2013 年 5 月开源； 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 特点 声明式 你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI 高效 React通过对DOM的模拟，最大限度地减少与DOM的交互。 基于组件 组件时React最重要的内容，组件表示页面中的部分内容 单向响应的数据流 React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React基本使用React的安装npm i react react-dom react 包是核心，提供创建元素，组件等功能 react-dom 包提供DOM相关功能 React的使用 1.引入react和react-dom的两个js文件 &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; 2.创建React元素 // 创建元素节点 // 1. 元素名称 // 2. 元素属性 传递的是个对象 // 3. 元素内容 let title = React.createElement(&#39;li&#39;, null, &#39;hellow react&#39;); 3.渲染到页面 // 渲染到页面 ReactDOM.render(title, document.getElementById(&#39;root&#39;)) React脚手架React脚手架意义 脚手架是开发现代Web应用的必备 充分利用 Webpack，Babel，ESLint等工具辅助项目开发 零配置，无需手动配置繁琐的工具即可使用 关注业务，而不是工具配置 使用React脚手架初始化项目 初始化项目，命令： npx create-react-app project npx 目的：提升包内提供的命令行工具的使用体验 原来：先安装脚手架包，再使用这个包中提供的命令 现在：无需安装脚手架包，就可以直接使用这个包提供的命令 create-react-app 这个是脚手架名称 不能随意更改 project 自己定义的项目名称 启动项目，在项目根目录执行命令： npm start 脚手架中使用React 1.导入react和react-dom两个包 import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; 2.创建元素 let h1 = React.createElement(&#39;h1&#39;,null,&#39;我是标题&#39;) 3.渲染到页面 ReactDOM.render(h1,document.getElementById(&#39;root&#39;)) JSX的使用JSX产生的原因由于通过createElement()方法创建的React元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽 JSX的概述JSX是JavaScript XML 的简写，表示在JavaScript代码中写HTML格式的代码 优势：声明式语法更加直观，与HTML结构相同，降低了学习成本，提升开发效率 简单使用 1.使用JSX语法创建react元素 let h1 = &lt;h1&gt;JSX创建的元素&lt;/h1&gt; 2.使用ReactDOM来渲染元素 ReactDOM.render(h1,document.getElementById(&#39;root&#39;)) 为什么在脚手架中可以使用JSX语法 JSX 不是标准的ECMAScript语法，它是ECMAScript的语法拓展 需要使用babel编译处理后，才能在浏览器环境中使用 create-react-app脚手架中已经默认有该配置，无需手动配置 编译JSX语法的包： @bable/preset-react 注意点 React元素的属性名使用驼峰命名法 特殊属性名：class -&gt; className，for -&gt; htmlFor，tabindex -&gt; tabIndex 如果没有子节点的React元素可以用 /&gt; 来结束 推荐：使用 小括号包裹JSX，从而避免JS中自动插入分号报错 JSX语法JSX是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在JSX中都能得到支持 嵌入JS表达式语法：{JavaScritp表达式} 例子： let content = &#39;插入的内容&#39; let h1 = &lt;h1&gt;我是通过JSX创建的元素+ {content}&lt;/h1&gt; 注意点 只要是合法的js表达式都可以进行嵌入 JSX自身也是js表达式 注意：js中的对象是一个例外，一般只会出现在style属性中 注意：在{}中不能出现语句 条件渲染根据不同的条件来渲染不同的JSX结构 let isLoading = true let loading = ()=&gt;{ if(isLoading){ return &lt;div&gt;Loading...&lt;/div&gt; } return &lt;div&gt;加载完成&lt;/div&gt; } 可以发现，写JSX的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 JSX结构，然后渲染到页面中 列表渲染 如果需要渲染一组数据，我们应该使用数组的 map () 方法 注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一 原则：map()遍历谁，就给谁添加key属性 注意：尽量避免使用索引号作为key let arr = [{ id:1, name:&#39;1&#39; },{ id:2, name:&#39;2&#39; },{ id:3, name:&#39;3&#39; }] let ul = (&lt;ul&gt; {arr.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)} &lt;/ul&gt;) ReactDOM.render(ul,document.getElementById(&#39;root&#39;)) 样式处理行内样式 -style在style里面我们通过对象的方式传递数据 &lt;li key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}&gt;{item.name}&lt;/li&gt; 注意：style里面放置着一个对象这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐 类名 -className创建CSS文件编写样式代码 .container { text-align: center } 在js中进行引入，然后设置类名即可 // 引入css样式 import &#39;./css/index.css&#39; &lt;li className=&#39;container&#39; key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}&gt;{item.name}&lt;/li&gt; 小结 JSX是React的核心内容 JSX表示在JS代码中写HTML结构，是React声明式的体现 使用JSX配合嵌入的JS表达式、条件渲染、列表渲染、可以描述任意UI结构 推荐使用className的方式给JSX添加样式 React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能 React组件React组件介绍 组件表示页面中的部分功能 组合多个组件实现完整的页面功能 特点：可复用、独立、可组合 组件的创建方式函数创建组件 函数组件：使用JS的函数创建组件 函数名称必须以大写字母开头 函数组件必须有返回值，表示该组件的结构 如果返回值为null，表示不渲染任何内容 示例demo编写函数组件 function Hello() { return ( &lt;div&gt;这是第一个函数组件&lt;/div&gt; ) } 利用ReactDOM.render()进行渲染 ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#39;root&#39;)) 类组件 使用ES6语法的class创建的组件 类名称也必须要大写字母开头 类组件应该继承React.Component父类，从而可以使用父类中提供的方法或者属性 类组件必须提供 render 方法 render方法中必须要有return返回值 示例demo创建class类，继承React.Component，在里面提供render方法，在return里面返回内容 class Hello extends React.Component{ render(){ return ( &lt;div&gt;这是第一个类组件&lt;/div&gt; ) } } 通过ReactDOM进行渲染 ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#39;root&#39;)) 抽离成单独的JS文件示例demo 创建Hello.js 在Hello.js 中导入React，创建组件，在Hello.js中导出 import React from &#39;react&#39; export default class extends React.Component { render(){ return ( &lt;div&gt;单独抽离出来的 Hello&lt;/div&gt; ) } } 在index.js中导入Hello组件，渲染到页面 import Hello from &#39;./js/Hello&#39; ReactDOM.render(&lt;Hello /&gt;,document.getElementById(&#39;root&#39;)) React事件处理事件绑定 React事件绑定语法与DOM事件语法相似 语法：on+事件名称=事件处理函数，比如 onClick = function(){} 注意：React事件采用驼峰命名法 示例demoexport default class extends React.Component { clickHandle(e){ console.log(&#39;点了&#39;) } render(){ return ( &lt;div&gt;&lt;button onClick = {this.clickHandle}&gt;点我点我点我&lt;/button&gt;&lt;/div&gt; ) } } // 渲染 ReactDOM.render(&lt;clickHandle/&gt;,document.getElementById(&#39;root&#39;)) 小结 在React中绑定事件与原生很类似 需要注意点在于，在React绑定事件需要遵循驼峰命名法 类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this 事件对象 可以通过事件处理函数的参数获取到事件对象 React中的事件对象叫做：合成事件 合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题 除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation()和 preventDefault() 如果你想获取到原生事件对象，可以通过 nativeEvent 属性来进行获取 示例demoexport default class extends React.Component { clickHandle(e){ // 获取原生事件对象 console.log(e.nativeEvent) } render(){ return ( &lt;div&gt;&lt;button onClick = {this.clickHandle}&gt;点我点我点我&lt;/button&gt;&lt;/div&gt; ) } } 支持的事件 Clipboard Events 剪切板事件 事件名 ：onCopy onCut onPaste 属性 ：DOMDataTransfer clipboardData compositionEvent 复合事件 事件名： onCompositionEnd onCompositionStart onCompositionUpdate 属性： string data Keyboard Events 键盘事件 事件名：onKeyDown onKeyPress onKeyUp 属性： 例如 number keyCode 太多就不一一列举 Focus Events 焦点事件 （这些焦点事件在 React DOM 上的所有元素都有效，不只是表单元素） 事件名： onFocus onBlur 属性： DOMEventTarget relatedTarget Form Events 表单事件 事件名： onChange onInput onInvalid onSubmit Mouse Events 鼠标事件 事件名： onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp Pointer Events 指针事件 事件名： onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut Selection Events 选择事件 事件名：onSelect Touch Events 触摸事件 事件名：onTouchCancel onTouchEnd onTouchMove onTouchStart UI Events UI 事件 事件名： onScroll Wheel Events 滚轮事件 事件名：onWheel 属性： number deltaMode number deltaX number deltaY number deltaZ Media Events 媒体事件 事件名： onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting Image Events 图像事件 事件名：onLoad onError Animation Events 动画事件 事件名：onAnimationStart onAnimationEnd onAnimationIteration Transition Events 过渡事件 事件名：onTransitionEnd Other Events 其他事件 事件名： onToggle 有状态组件和无状态组件 函数组件又叫做 无状态组件，类组件又叫做 有状态组件 状态(state) 即数据 函数组件没有自己的状态，只负责数据展示 类组件有自己的状态，负责更新UI，让页面动起来 State和SetStatestate基本使用 状态(state)即数据，是组件内部的私有数据，只能在组件内部使用 state的值是对象，表示一个组件中可以有多个数据 通过this.state来获取状态 示例demoexport default class extends React.Component { constructor(){ super() // 第一种初始化方式 this.state = { count : 0 } } // 第二种初始化方式 简化语法 state = { count:1 } render(){ return ( &lt;div&gt;计数器 :{this.state.count}&lt;/div&gt; ) } } setState() 修改状态 状态是可变的 语法：this.setState({要修改的数据}) 注意：不要直接修改state中的值，这是错误的 setState() 作用：1.修改 state 2.更新UI 思想：数据驱动视图 示例demoexport default class App extends React.Component { // 第二种初始化方式 state = { count:1 } render(){ return ( &lt;div&gt; &lt;div&gt;计数器 :{this.state.count}&lt;/div&gt; &lt;button onClick={() =&gt; { this.setState({ count: this.state.count+1 }) }}&gt;+1&lt;/button&gt; &lt;/div&gt; ) } } 小结 修改state里面的值我们需要通过 this.setState() 来进行修改 React底层会有监听，一旦我们调用了setState导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件 抽取事件处理函数 当我们把上面代码的事件处理程序抽取出来后，会报错，找不到this 原因 在JSX中我们写的事件处理函数可以找到this，原因在于在JSX中我们利用箭头函数，箭头函数是不会绑定this，所以会向外一层去寻找，外层是render方法，在render方法里面的this刚好指向的是当前实例对象 事件绑定this指向箭头函数 利用箭头函数自身不绑定this的特点 利用bind方法利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可 class App extends React.Component { constructor() { super() ... // 通过bind方法改变了当前函数中this的指向 this.onIncrement = this.onIncrement.bind(this) } // 事件处理程序 onIncrement() { ... } render() { ... } } class的实例方法 利用箭头函数形式的class实例方法 注意：该语法是实验性语法，但是，由于babel的存在可以使用 // 事件处理程序 onIncrement = () =&gt; { console.log(&#39;事件处理程序中的this：&#39;, this) this.setState({ count: this.state.count + 1 }) } 小结 推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因","categories":[{"name":"web 技术","slug":"web-技术","permalink":"/categories/web-技术/"}],"tags":[],"keywords":[{"name":"web 技术","slug":"web-技术","permalink":"/categories/web-技术/"}]},{"title":"前端常见面试题总结（2019）","slug":"mianshi2019","date":"2020-01-07T11:34:55.000Z","updated":"2020-01-07T11:52:46.498Z","comments":true,"path":"2020/01/07/mianshi2019/","link":"","permalink":"/2020/01/07/mianshi2019/","excerpt":"","text":"1、什么是mvvm、mvc 模型？MVC: MVC即model-view-controller（模型-视图-控制器）是项目的一种分层架构思想，它把复杂的业务逻辑，抽离为职能单一的小模块，每个模块看似相互独立，其实又各自有相互依赖关系。它的好处是：保证了模块的智能单一性，方便程序的开发、维护、耦合度低。mvvm: MVVM：MVVM即 Model-View-ViewModel，(模型-视图-控制器)它是一种双向数据绑定的模式，用viewModel来建立起model数据层和view视图层的连接，数据改变会影响视图，视图改变会影响数据 2、vue双向数据绑定的原理？ vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 3、vue的生命周期有哪些？ vue 实例从创建到销毁的过程就是生命周期。 也就是从开始创建、初始化数据、编译模板、挂在 dom -&gt; 渲染、更新 -&gt; 渲染、准备销毁、销毁在等一系列过程 vue的声明周期常见的主要分为4大阶段8大钩子函数 另外三个生命周期函数不常用 keep-alive 主要用于保留组件状态或避免重新渲染。 activated只有在keep-alive 组件激活时调用。 deactivated只有在keep-alive 组件停用时调用。 errorCapured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 一、创建前 / 后 在beforeCreate生命周期函数执行的时候，data和method 还没有初始化 在created 生命周期函数执行的时候，data和method已经初始化完成 二、渲染前/后 在beforeMount 生命周期函数执行的时候，已经编译好了模版字符串、但还没有真正渲染到页面中去 在mounted 生命周期函数执行的时候，已经渲染完，可以看到页面 三、数据更新前/后 在beforeUpdate生命周期函数执行的时候，已经可以拿到最新的数据，但还没渲染到视图中去。 在updated生命周期函数执行的时候，已经把更新后的数据渲染到视图中去了。 四、销毁前/后 在beforeDestroy 生命周期函数执行的时候，实例进入准备销毁的阶段、此时data 、methods 、指令等还是可用状态 在destroyed生命周期函数执行的时候，实例已经完成销毁、此时data 、methods 、指令等都不可用 4、v-if 和v-show有什么区别？v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，操作的实际上是dom元素的创建或销毁。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 它操作的是display:none/block属性。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 5、async await 是什么？它有哪些作用？async await 是es7里面的新语法、它的作用就是 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。它可以很好的替代promise 中的then async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 6、常用的数组方法有哪些？ concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。 **find()** 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 **findIndex()**方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 **includes()** 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 **indexOf()**方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 （通常用它判断数组中有没有这个元素） **join()** 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。 **pop()**方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 **push()** 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 **shift()** 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。 **reverse()** 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。 **sort()** 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 7、数组有哪几种循环方式？分别有什么作用？**every()** 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 **filter()** 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 **forEach()** 方法对数组的每个元素执行一次提供的函数。 **some()** 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。 8、常用的字符串方法有哪些？charAt() 方法从一个字符串中返回指定的字符。 concat() 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 includes() 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。 indexOf() 方法返回调用它的 String 对象中第一次出现的指定值的索引，从 fromIndex 处进行搜索。如果未找到该值，则返回 -1。 match() 方法检索返回一个字符串匹配正则表达式的的结果。 padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 (常用于时间补0) replace() 方法返回一个由替换值（replacement）替换一些或所有匹配的模式（pattern）后的新字符串。模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。 原字符串不会改变。 slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。 **split()**方法使用指定的分隔符字符串将一个String对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。 **substr()** 方法返回一个字符串中从指定位置开始到指定字符数的字符。 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 9、什么是原型链？每一个实例对象上有一个proto属性，指向的构造函数的原型对象，构造函数的原型 对象也是一个对象，也有proto属性，这样一层一层往上找的过程就形成了原型链。 10、什么是闭包？手写一个闭包函数？ 闭包有哪些优缺点？闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用 域可以访问另外一个函数内部的局部变量。 function fn() { var num = 10; function fun() { console.log(num); } return fun; } var f = fn(); f(); 作用：延长变量作用域、在函数的外部可以访问函数内部的局部变量，容易造成内层泄露，因为闭包中的局部变量永远不会被回收 11、常见的继承有哪些？一、原型链继承 特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！ 缺点：1、新实例无法向父类构造函数传参。 2、继承单一。 3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原 型属性也会被修改！） 二、借用构造函数继承 重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制）） 特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。 2、解决了原型链继承缺点1、2、3。 3、可以继承多个构造函数属性（call多个）。 4、在子实例中可向父实例传参。 缺点：1、只能继承父类构造函数的属性。 2、无法实现构造函数的复用。（每次用每次都要重新调用） 3、每个新实例都有父类构造函数的副本，臃肿。 三、组合继承（组合原型链继承和借用构造函数继承）（常用） 重点：结合了两种模式的优点，传参和复用 特点：1、可以继承父类原型上的属性，可以传参，可复用。 2、每个新实例引入的构造函数属性是私有的。 缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。 四、原型式继承 重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。 特点：类似于复制一个对象，用函数来包装。 缺点：1、所有实例都会继承原型上的属性。 2、无法实现复用。（新实例属性都是后面添加的） 五、class类实现继承 通过extends 和super 实现继承 六、寄生式继承 重点：就是给原型式继承外面套了个壳子。 优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。 缺点：没用到原型，无法复用。 12、后台管理系统中的权限管理是怎么实现的？登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过token获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。 具体思路： 登录成功后，服务端会返回一个 token（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。 ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号。 用户登录成功之后，我们会在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了 页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。 先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role ，动态根据用户的 role 算出其对应有权限的路由，再通过router.addRoutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。 我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 具体实现： 创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。 当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 14、es6有哪些新特性？ES6是2015年推出的一个新的版本、这个版本相对于ES5的语法做了很多的优化、例如：新增了let、const let和const具有块级作用域，不存在变量提升的问题。新增了箭头函数，简化了定义函数的写法，同时可以巧用箭头函数的this、（注意箭头函数本身没有this,它的this取决于外部的环境），新增了promise解决了回调地域的问题，新增了模块化、利用import 、export来实现导入、导出。新增了结构赋值，ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。新增了class类的概念，它类似于对象。 15、v-for 循环为什么一定要绑定key ?页面上的标签都对应具体的虚拟dom对象(虚拟dom就是js对象), 循环中 ,如果没有唯一key , 页面上删除一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟dom重新渲染, 如果知道key为x标签被删除掉, 只需要把渲染的dom为x的标签去掉即可! 16、组件中的data为什么要定义成一个函数而不是一个对象？每个组件都是 Vue 的实例。组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 17、常见的盒子垂直居中的方法有哪些请举例3种？利用子绝父相定位的方式来实现 #container{ width:500px; height:500px; position:relative; } #center{ width:100px; hight:100px; position: absolute; top: 50%; left: 50%; margin-top:-50px; margin-left:-50px; } 利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。 #container{ position:relative; } #center{ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex #container{ display:flex; justify-content:center; align-items: center; } #center{ } 18、平时都是用什么实现跨域的？jsonp: 利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。 JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。 创建一个&lt;script&gt;标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是show(&#39;我不爱你&#39;)。 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 CORS：跨域资源共享（CORS）是一种机制；当一个资源访问到另外一个资源(这个资源放在 不同的域名或者不同的协议或者端口)，资源就会发起一个跨域的HTTP请求需要浏览器和服务器同时支持； 整个CORS通信，都是浏览器自动完成。浏览器发现了AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉； 实现CORS的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信 服务器对于不同的请求，处理方式不一样； 有简单请求和非简单请求 19、cookie 、localstorage 、 sessionstrorage 之间有什么区别？ 与服务器交互： cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密） cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小： cookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关 20、this 的指向有哪些？1、普通函数中的this指向window 2、定时器中的this指向window 3、箭头函数没有this,它的this指向取决于外部环境、 4、事件中的this指向事件的调用者 5、 构造函数中this和原型对象中的this,都是指向构造函数new 出来实例对象 6、类 class中的this 指向由constructor构造器new出来的实例对象 7、自调用函数中的this 指向window 21、什么是递归，递归有哪些优点或缺点？递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函 数内部自己调用自己, 这个函数就是递归函数 优点：结构清晰、可读性强 缺点：效率低、调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。-&gt;性能 22、谈谈你平时都用了哪些方法进行性能优化？减少http请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN加载包。 23、vue实例是挂载到那个标签上的？vue实例最后会挂载在body标签里面，所以我们在vue中是获取不了body 标签的，如果要使用body标签的话需要用原生的方式获取 24、什么是深拷贝、什么是浅拷贝？浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。 25、js的执行机制是怎么样的？js是一个单线程、异步、非阻塞I/O模型、 event loop事件循环的执行机制 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 26、请写至少三种数组去重的方法？（原生js）//利用filter function unique(arr) { return arr.filter(function(item, index, arr) { //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; }); } var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}]; console.log(unique(arr)) //利用ES6 Set去重（ES6中最常用） function unique (arr) { return Array.from(new Set(arr)) } var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {}, {}] //利用for嵌套for，然后splice去重（ES5中最常用） function unique(arr){ for(var i=0; i&lt;arr.length; i++){ for(var j=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){ //第一个等同于第二个，splice方法删除第二个 arr.splice(j,1); j--; } } } return arr; } var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,{},{}]; console.log(unique(arr)) //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, {…}, {…}] //NaN和{}没有去重，两个null直接消失了 27、请写出至少两种常见的数组排序的方法（原生js）//快速排序 function quickSort(elements){ if(elements.length &lt;=1){ return elements; } var pivotIndex=Math.floor(elements.length / 2); var pivot=elements.splice(pivotIndex,1)[0]; var left=[]; var right=[]; for(var i=0;i&lt;elements.length;i++){ if(elements[i] &lt; pivot){ left.push(elements[i]); }else{ right.push(elements[i]); } } return quickSort(left).concat([pivot],quickSort(right)); //concat()方法用于连接两个或者多个数组；该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 }; var elements=[3,5,6,8,2,4,7,9,1,10]; document.write(quickSort(elements)); //插入排序 function sort(elements){ // 假设第0个元素是一个有序数列，第1个以后的是无序数列， // 所以从第1个元素开始将无序数列的元素插入到有序数列中去 for (var i =1; i&lt;=elements.length; i++) { // 升序 if(elements[i] &lt; elements[i-1]){ // 取出无序数列中的第i个作为被插入元素 var guard=elements[i]; //记住有序数列的最后一个位置，并且将有序数列的位置扩大一个 var j=i-1; elements[i]=elements[j]; // 比大小;找到被插入元素所在位置 while (j&gt;=0 &amp;&amp; guard &lt;elements[j]) { elements[j+1]=elements[j]; j--; } elements[j+1]=guard; //插入 } } } var elements=[3,5,6,8,2,4,7,9,1,10]; document.write(&#39;没调用之前：&#39;+elements); document.write(&#39;&lt;br&gt;&#39;); sort(elements); document.write(&#39;被调用之后：&#39;+elements); //冒泡排序 function sort(elements){ for(var i=0;i&lt;elements.length-1;i++){ for(var j=0;j&lt;elements.length-1-i;j++){ if(elements[j] &gt; elements[j+1]){ var swap=elements[j]; elements[j]=elements[j+1]; elements[j+1]=swap; } } } } var elements=[3,5,6,8,2,4,7,9,1,10]; console.log(&#39;before&#39;+elements); sort(elements); console.log(&#39;after&#39;+elements); 28、知道lodash吗？它有哪些常见的API ？Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。 ​ _.cloneDeep 深度拷贝 _.reject 根据条件去除某个元素。 _.drop(array, [n=1] ) 作用：将 array 中的前 n 个元素去掉，然后返回剩余的部分. 29、http的请求方式有哪些？get、post、put、delete等 30、平时都是用那些工具进行打包的？babel是什么？WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源 babel可以帮助我们转换一些当前浏览器不支持的语法，它会把这些语法转换为低版本的语法以便浏览器识别。 31、谈谈set 、 map 是什么？set 是es6 提供的一种新的数据结构，它类似于数组，但是成员的值都是唯一的。 map 是es6 提供的一种新的数据结构,它类似于对象，也是键值对的集合，但是键的范围不仅限于字符串，各种类型的值都可以当做键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 32、清除浮动的方法有哪些？为什么要清除浮动，因为浮动的盒子脱离标准流，如果父盒子没有设置高度的话，下面的盒子就会撑上来。 1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐） 2.父级添加overflow属性（父元素添加overflow:hidden）（不推荐） 3.使用after伪元素清除浮动（推荐使用） .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/ content: &quot;&quot;; display: block; height: 0; clear:both; visibility: hidden; } .clearfix{ *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/ ｝ 4.使用before和after双伪元素清除浮动 .clearfix:after,.clearfix:before{ content: &quot;&quot;; display: table; } .clearfix:after{ clear: both; } .clearfix{ *zoom: 1; } 33、常见的布局方法有哪些？他们的优缺点是什么？页面布局常用的方法有浮动、定位、flex、grid网格布局、栅格系统布局 浮动： 优点：兼容性好。 缺点：浮动会脱离标准文档流，因此要清除浮动。我们解决好这个问题即可。 绝对定位 优点：快捷。 缺点：导致子元素也脱离了标准文档流，可实用性差。 flex 布局（CSS3中出现的） 优点：解决上面两个方法的不足，flex布局比较完美。移动端基本用 flex布局。 网格布局（grid） CSS3中引入的布局，很好用。代码量简化了很多。 利用网格布局实现的一个左右300px中间自适应的布局 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html * { padding: 0; margin: 0; } /* 重要：设置容器为网格布局，宽度为100% */ .layout.grid .left-center-right { display: grid; width: 100%; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; /* 重要：设置网格为三列，并设置每列的宽度。即可。*/ } .layout.grid .left { background: red; } .layout.grid .center { background: green; } .layout.grid .right { background: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;section class=&quot;layout grid&quot;&gt; &lt;article class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt; 我是 left &lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h1&gt;网格布局解决方案&lt;/h1&gt; 我是 center &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 我是 right &lt;/div&gt; &lt;/article&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 栅格系统布局 ​ 优点：可以适用于多端设备 34、图片懒加载是怎么实现的？就是我们先设置图片的data-set属性（当然也可以是其他任意的，只要不会发送http请求就行了，作用就是为了存取值）值为其图片路径，由于不是src，所以不会发送http请求。 然后我们计算出页面scrollTop的高度和浏览器的高度之和， 如果图片距离页面顶端的坐标Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属性替换为 src 属性即可。 35、vue中computed 和watch 的区别是什么？computed计算属性就是为了简化template里面模版字符串的计算复杂度、防止模版太过冗余。它具有缓存特性 computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，然后就可以在页面上进行双向数据绑定展示出结果或者用作其他处理； ​ watch主要用于监控vue实例的变化，它监控的变量当然必须在data里面声明才可以，它可以监控一个变量，也可以是一个对象，一般用于监控路由、input输入框的值特殊处理等等，它比较适合的场景是一个数据影响多个数据，它不具有缓存性 watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。 computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。 除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。 36、vue中是怎么实现父向子、子向父、兄弟之间的传值的？父向子传值主要通过的是props属性来传值，props只读 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;父组件向子组件传值--props&lt;/title&gt; &lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;menu-item title=&quot;来自父组件的值&quot;&gt;&lt;/menu-item&gt; &lt;!-- 在子组件身上绑定自定义属性来接收父组件data中的数据 --&gt; &lt;menu-item :tit=&quot;title&quot;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#39;menu-item&#39;,{ props:[&#39;tit&#39;], //props用来接收父组件传过来的值 //在props中使用驼峰形式，模版中要改为使用短横线拼接 props里面的值只读，不能修改 //props是单向数据流 data(){ return{ } }, template:&#39;&lt;div&gt;{{tit}}&lt;/div&gt;&#39; }) var vm=new Vue({ el:&#39;#app&#39;, data:{ title:&#39;我是父组件中的数据&#39; }, methods:{ } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 子向父传值 $emit &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 父组件 --&gt; &lt;div :style=&#39;{fontSize:fontSize+&quot;px&quot;}&#39;&gt;{{pmsg}}&lt;/div&gt; &lt;!-- 子组件 --&gt; &lt;menu-item :parr=&quot;parr&quot; @aas=&quot;blune&quot;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 子组件向父组件传值-基本用法 props传递数据原则：单向数据流 */ Vue.component(&#39;menu-item&#39;, { props:[&#39;parr&#39;], data(){ return { msg1:&#39;这是子组件传递过来的值&#39; } }, template: ` &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in parr&quot; :key=&quot;index&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;button @click=&#39;dd&#39;&gt;扩大父组件中字体大小&lt;/button&gt; &lt;/div&gt; `, methods:{ dd(){ this.$emit(&quot;aas&quot;,this.msg1) } } }); //$emit var vm = new Vue({ el: &#39;#app&#39;, data: { pmsg: &#39;父组件中内容&#39;, parr: [&#39;apple&#39;,&#39;orange&#39;,&#39;banana&#39;], fontSize: 10 }, methods: { blune(message){ this.fontSize+=5; console.log(message); } } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 兄弟组件传值 事件总线 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./js/vue.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;brother&gt;&lt;/brother&gt; &lt;sister&gt;&lt;/sister&gt; &lt;/div&gt; &lt;script&gt; var enveBus = new Vue(); Vue.component(&#39;brother&#39;, { data() { return { kk: &#39;&#39; } }, methods: { dd() { enveBus.$emit(&quot;bTs&quot;, &#39;这是哥哥给妹妹的爱&#39;) } }, template: ` &lt;div&gt; &lt;button @click=&#39;dd&#39;&gt;这是一个哥哥组件---{{kk}}&lt;/button&gt; &lt;/div&gt; `, mounted() { enveBus.$on(&#39;asd&#39;, (result) =&gt; { this.kk = result; }) } }); Vue.component(&#39;sister&#39;, { data() { return { sis: &#39;&#39; } }, template: ` &lt;div&gt; &lt;button @click=&quot;cc&quot;&gt;这是一个妹妹组件---{{sis}}&lt;/button&gt; &lt;/div&gt; `, mounted() { enveBus.$on(&#39;bTs&#39;, (message) =&gt; { this.sis = message }) }, methods: { cc() { enveBus.$emit(&#39;asd&#39;, &#39;这是妹妹对哥哥的爱&#39;); } } }); var vm = new Vue({ el: &#39;#app&#39;, data: { }, methods: { } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 37、什么vuex ,谈谈你对它的理解？ 首先vuex的出现是为了解决web组件化开发的过程中，各组件之间传值的复杂和混乱的问题 将我们在多个组件中需要共享的数据放到store中， 要获取或格式化数据需要使用getters， 改变store中的数据，使用mutation，但是只能包含同步的操作，在具体组件里面调用的方式this.$store.commit(&#39;xxxx&#39;) Action也是改变store中的数据，不过是提交的mutation，并且可以包含异步操作，在组件中的调用方式this.$store.dispatch(&#39;xxx&#39;)； 在actions里面使用的commit(‘调用mutation’) 38、数据类型的判断有哪些方法？他们的优缺点及区别是什么？然后判断数据类型的方法一般可以通过：typeof、instanceof、constructor、toString四种常用方法 不同类型的优缺点 typeof instanceof constructor Object.prototype.toString.call 优点 使用简单 能检测出引用类型 基本能检测所有的类型（除了null和undefined） 检测出所有的类型 缺点 只能检测出基本类型（出null） 不能检测出基本类型，且不能跨iframe constructor易被修改，也不能跨iframe IE6下，undefined和null均为Object 39、知道symbol 吗？ES6 引入新的原始数据类型Symbol，表示独一无二的值 40、请描述一下ES6中的class类?es6中的class可以把它看成是es5中构造函数的语法糖，它简化了构造函数的写法， 类的共有属性放到 constructor 里面 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用 父类的构造函数,super 必须在子类this之前调用 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. constructor中的this指向的是new出来的实例对象 自定义的方法,一般也指向的new出来的实例对象 绑定事件之后this指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 41、谈谈盒子模型？在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 42、promise是什么？它有哪些作用？ Promise 是异步编程的一种解决方案.简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，可以从改对象获取异步操作的消息。 它可以解决回调地狱的问题，也就是异步深层嵌套问题 .catch() 获取异常信息 .finally() 成功与否都会执行（不是正式标准） /* 1. Promise基本使用 我们使用new来构建一个Promise Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数 */ var p = new Promise(function(resolve, reject){ //2. 这里用于实现异步任务 setTimeout setTimeout(function(){ var flag = false; if(flag) { //3. 正常情况 resolve(&#39;hello&#39;); }else{ //4. 异常情况 reject(&#39;出错了&#39;); } }, 100); }); // 5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 // 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 p.then(function(data){ console.log(data) },function(info){ console.log(info) }); 43、vue-cli 2.0和3.0 有什么区别？3.0 把配置webpack的文件隐藏了，如果需要配置它需要创建一个vue.config.js文件，3.0 是2018.10月出来的 44、箭头函数有哪些特征，请简单描述一下它？箭头函数没有自己的this，this指向定义箭头函数时所处的外部执行环境的this 即时调用call/apply/bind也无法改变箭头函数的this 箭头函数本身没有名字 箭头函数不能new，会报错 箭头函数没有arguments，在箭头函数内访问这个变量访问的是外部执行环境的arguments 箭头函数没有prototype 45、移动端有哪些常见的问题，都是怎么解决的？点击事件300MS延迟问题 解决方案：下载fastclick的包 H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt; 忽略Android平台中对邮箱地址的识别 &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 46、post和get 请求有哪些区别？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 47、什么是同源策略？所谓同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信。同源就是域名、协议、端口一致。 48、http状态码分别代表什么意思？1xx 表示HTTP请求已经接受，继续处理请求2xx 表示HTTP请求已经处理完成(200)3xx 表示把请求访问的URL重定向到其他目录(304资源没有发生变化，会重定向到本地资源)4xx 表示客户端出现错误(403禁止访问、404资源不存在)5xx 表示服务端出现错误 49、BFC是什么？BFC（会计格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题。 BFC是值浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 50、token是什么？（加密） token也可以称做令牌，一般由 uid+time+sign(签名)+[固定参数] 组成 uid: 用户唯一身份标识 time: 当前时间的时间戳 sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接 固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库 token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中 token 的认证流程 用户登录，成功后服务器返回Token给客户端。 客户端收到数据后保存在客户端 客户端再次访问服务器，将token放入headers中 或者每次的请求 参数中 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 token可以抵抗csrf，cookie+session不行 session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session 客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token) 51、js的数据类型有哪些？js的数据类型分为基本数据类型（string、number、boolean、null、undefined、symbol）和复杂数据类型 基本数据类型的特点：直接存储在栈中的数据 复杂数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里 52、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器) 02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手） 03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com） 04.浏览器跟踪重定向地址，请求另一个带 www 的网址 05.服务器处理请求（通过路由读取资源） 06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’） 07.浏览器进 DOM 树构建 08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等） 09.浏览器显示完成页面 10.浏览器发送异步请求 53、安全问题 ：CSRF 和 XSS攻击？CSRF（Cross-site request forgery）：跨站请求伪造。 方法一、Token 验证：（用的最多） 服务器发送给客户端一个token； 客户端提交的表单中带着这个token。 如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌： 把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。 方法三、Referer 验证： Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截 XSS（Cross Site Scripting）：跨域脚本攻击。 1. 编码： 对用户输入的数据进行HTML Entity编码。 如上图所示，把字符转换成 转义字符。 Encode的作用是将$var`等一些字符进行转化，使得浏览器在最终输出结果上是一样的。 比如说这段代码： &lt;script&gt;alert(1)&lt;/script&gt; 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，L在浏览器中的显示结果就是&lt;script&gt;alert(1)&lt;/script&gt;，实现了将$var作为纯文本进行输出，且不引起JavaScript`的执行。 2、过滤： 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容） 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正 避免直接对HTML Entity进行解码。 使用DOM Parse转换，校正不配对的DOM标签。 备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。 比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。 54、CSRF 和 XSS 的区别区别一： CSRF：需要用户先登录网站A，获取 cookie XSS：不需要登录。 区别二：（原理的区别） CSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 55、cookie和session 的区别 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 56、call、apply、bind三者的异同共同点 : 都可以改变this指向;不同点:call 和 apply 会调用函数, 并且改变函数内部this指向.call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递bind 不会调用函数, 可以改变函数内部this指向.应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"vue基础学习（四）","slug":"vue4","date":"2020-01-07T11:13:03.000Z","updated":"2020-01-07T11:33:17.227Z","comments":true,"path":"2020/01/07/vue4/","link":"","permalink":"/2020/01/07/vue4/","excerpt":"","text":"1.路由的概念路由的本质就是一种对应关系，比如说我们在url地址中输入我们要访问的url地址之后，浏览器要去请求这个url地址对应的资源。那么url地址和真实的资源之间就有一种对应的关系，就是路由。 路由分为前端路由和后端路由1).后端路由是由服务器端进行实现，并完成资源的分发2).前端路由是依靠hash值(锚链接)的变化进行实现 后端路由性能相对前端路由来说较低，所以，我们接下来主要学习的是前端路由前端路由的基本概念：根据不同的事件来显示不同的页面内容，即事件与事件处理函数之间的对应关系前端路由主要做的事情就是监听事件并分发执行事件处理函数 2.前端路由的初体验前端路由是基于hash值的变化进行实现的（比如点击页面中的菜单或者按钮改变URL的hash值，根据hash值的变化来控制组件的切换）核心实现依靠一个事件，即监听hash值变化的事件 window.onhashchange = function(){ //location.hash可以获取到最新的hash值 location.hash } 3.Vue Router简介它是一个Vue.js官方提供的路由管理器。是一个功能更加强大的前端路由器，推荐使用。Vue Router和Vue.js非常契合，可以一起方便的实现SPA(single page web application,单页应用程序)应用程序的开发。Vue Router依赖于Vue，所以需要先引入Vue，再引入Vue Router Vue Router的特性：支持H5历史模式或者hash模式支持嵌套路由支持路由参数支持编程式路由支持命名路由支持路由导航守卫支持路由过渡动画特效支持路由懒加载支持路由滚动行为 4.Vue Router的使用步骤&lt;!DOCTYPE html&gt; &lt;html lang=&#39;en&#39;&gt; &lt;head&gt; &lt;meta charset=&#39;UTF-8&#39;&gt; &lt;meta name=&#39;viewport&#39; content=&#39;width=device-width, initial-scale=1.0&#39;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&#39;text/javascript&#39; src=&#39;../js/vue.js&#39;&gt;&lt;/script&gt; &lt;!--1. 导入router文件 一定要在vue文件之后 --&gt; &lt;script src=&quot;../js/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#39;app&#39;&gt; &lt;!--2. 路由链接地址 --&gt; &lt;router-link to=&quot;/user&quot;&gt;user&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;regiter&lt;/router-link&gt; &lt;!--3. 路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=&#39;text/javascript&#39;&gt; //4.创建组件 var user = { template:`&lt;p&gt;user组件&lt;/p&gt;` } var register = { template:`&lt;p&gt;register组件&lt;/p&gt;` } //5.创建路由实列对象 const router = new VueRouter({ //routes 所有的路由规则 routes:[ {path:&#39;/user&#39;,component:user}, {path:&#39;/register&#39;,component:register} ] }) var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; }, // 6.挂载 router }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 小结：Vue Router的使用步骤还是比较清晰的，按照步骤一步一步就能完成路由操作 1.导入js文件(vue-router文件一定要在vue文件下面) 2.添加路由链接 3.添加路由占位符(最后路由展示的组件就会在占位符的位置显示) 4.定义路由组件 5.配置路由规则并创建路由实例 6.将路由挂载到Vue实例中 补充：路由重定向：可以通过路由重定向为页面设置默认展示的组件在路由规则中添加一条路由规则即可，如下： var Router = new VueRouter({ //routes是路由规则数组 routes: [ //path设置为/表示页面最初始的地址 / ,redirect表示要被重定向的新地址，设置为一个路由即可 { path:&quot;/&quot;,redirect:&quot;/user&quot;}, { path: &quot;/user&quot;, component: User }, { path: &quot;/login&quot;, component: Login } ] }) 5.嵌套路由，动态路由的实现方式#A.嵌套路由的概念当我们进行路由的时候显示的组件中还有新的子级路由链接以及内容。 嵌套路由最关键的代码在于理解子级路由的概念：比如我们有一个/login的路由那么/login下面还可以添加子级路由，如:/login/account/login/phone 参考代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&#39;en&#39;&gt; &lt;head&gt; &lt;meta charset=&#39;UTF-8&#39;&gt; &lt;meta name=&#39;viewport&#39; content=&#39;width=device-width, initial-scale=1.0&#39;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&#39;text/javascript&#39; src=&#39;../js/vue.js&#39;&gt;&lt;/script&gt; &lt;!--1. 导入router文件 一定要在vue文件之后 --&gt; &lt;script src=&quot;../js/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#39;app&#39;&gt; &lt;!--2. 路由链接地址 --&gt; &lt;router-link to=&quot;/user&quot;&gt;user&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;regiter&lt;/router-link&gt; &lt;!--3. 路由的占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=&#39;text/javascript&#39;&gt; //4.创建组件 var user = { template:`&lt;p&gt;user组件&lt;/p&gt;` } var register = { template:`&lt;p&gt; &lt;span&gt;register组件&lt;/span&gt; &lt;br/&gt; &lt;router-link to=&quot;/register/tab1&quot;&gt;tab1&lt;/router-link&gt; &lt;router-link to=&quot;/register/tab2&quot;&gt;tab2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/p&gt;` } var tab1 = { template:`&lt;p&gt;tab1子组件&lt;/p&gt;` } var tab2 = { template:`&lt;p&gt;tab2子组件&lt;/p&gt;` } //5.创建路由实列对象 const router = new VueRouter({ //routes 所有的路由规则 routes:[ {path:&#39;/&#39;,redirect:&#39;/register&#39;}, {path:&#39;/user&#39;,component:user}, {path:&#39;/register&#39;,component:register,children:[ {path:&#39;/register/tab1&#39;,component:tab1}, {path:&#39;/register/tab2&#39;,component:tab2}, ]} ] }) var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; }, // 6.挂载 router }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; #B.动态路由匹配 var User = { template:&quot;&lt;div&gt;用户：{{$route.params.id}}&lt;/div&gt;&quot;} var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 { path: &quot;/user/:id&quot;, component: User }, ] }) 补充： 如果使用$route.params.id来获取路径传参的数据不够灵活。 1.我们可以通过props来接收参数 var User = { props:[&quot;id&quot;], template:&quot;&lt;div&gt;用户：{{id}}&lt;/div&gt;&quot; } var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为true，route.params将会被设置为组件属性 { path: &quot;/user/:id&quot;, component: User,props:true }, ] }) 2.还有一种情况，我们可以将props设置为对象，那么就直接将对象的数据传递给组件进行使用 var User = { props:[&quot;username&quot;,&quot;pwd&quot;], template:&quot;&lt;div&gt;用户：{{username}}---{{pwd}}&lt;/div&gt;&quot; } var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为对象，则传递的是对象中的数据给组件 { path: &quot;/user/:id&quot;, component: User,props:{username:&quot;jack&quot;,pwd:123} }, ] }) 3.如果想要获取传递的参数值还想要获取传递的对象数据，那么props应该设置为函数形式。 var User = { props:[&quot;username&quot;,&quot;pwd&quot;,&quot;id&quot;], template:&quot;&lt;div&gt;用户：{{id}} -&gt; {{username}}---{{pwd}}&lt;/div&gt;&quot; } var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过/:参数名 的形式传递参数 //如果props设置为函数，则通过函数的第一个参数获取路由对象 //并可以通过路由对象的params属性获取传递的参数 // { path: &quot;/user/:id&quot;, component: User,props:(route)=&gt;{ return {username:&quot;jack&quot;,pwd:123,id:route.params.id} } }, ] }) 6.命名路由以及编程式导航#A.命名路由：给路由取别名var myRouter = new VueRouter({ //routes是路由规则数组 routes: [ //通过name属性为路由添加一个别名 { path: &quot;/user/:id&quot;, component: User, name:&quot;user&quot;}, ] }) //添加了别名之后，可以使用别名进行跳转 &lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link&gt; &lt;router-link :to=&quot;{ name:&#39;user&#39; , params: {id:123} }&quot;&gt;User&lt;/router-link&gt; #B.编程式导航页面导航的两种方式：A.声明式导航：通过点击链接的方式实现的导航B.编程式导航：调用js的api方法实现导航 Vue-Router中常见的导航方式： this.$router.push(&quot;hash地址&quot;); this.$router.push(&quot;/login&quot;); this.$router.push({ name:&#39;user&#39; , params: {id:123} }); this.$router.push({ path:&quot;/login&quot; }); this.$router.push({ path:&quot;/login&quot;,query:{username:&quot;jack&quot;} }); this.$router.go( n );//n为数字，参考history.go this.$router.go( -1 );","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"前后端交互","slug":"axios","date":"2020-01-04T11:41:33.000Z","updated":"2020-01-04T11:46:25.571Z","comments":true,"path":"2020/01/04/axios/","link":"","permalink":"/2020/01/04/axios/","excerpt":"","text":"前后端接口调用方式 原生ajax 基于jQuery的ajax fetch axios 异步 JavaScript的执行环境是「单线程」 所谓单线程，是指JS引擎中负责解释和执行JavaScript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程 异步模式可以一起执行多个任务 JS中常见的异步调用 定时任何 ajax 事件函数 promise 主要解决异步深层嵌套的问题 promise 提供了简洁的API 使得异步操作更加容易 &lt;script type=&quot;text/javascript&quot;&gt; /* 1. Promise基本使用 我们使用new来构建一个Promise Promise的构造函数接收一个参数，是函数，并且传入两个参数： resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数 */ var p = new Promise(function(resolve, reject){ //2. 这里用于实现异步任务 setTimeout setTimeout(function(){ var flag = false; if(flag) { //3. 正常情况 resolve(&#39;hello&#39;); }else{ //4. 异常情况 reject(&#39;出错了&#39;); } }, 100); }); // 5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 // 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 p.then(function(data){ console.log(data) },function(info){ console.log(info) }); &lt;/script&gt; 基于Promise发送Ajax请求 &lt;script type=&quot;text/javascript&quot;&gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { # 1.1 创建一个Promise实例 var p = new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) { # 1.2 处理正常的情况 resolve(xhr.responseText); }else{ # 1.3 处理异常情况 reject(&#39;服务器错误&#39;); } }; xhr.open(&#39;get&#39;, url); xhr.send(null); }); return p; } # 注意： 这里需要开启一个服务 # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了 queryData(&#39;http://localhost:3000/data&#39;) .then(function(data){ console.log(data) # 1.4 想要继续链式编程下去 需要 return return queryData(&#39;http://localhost:3000/data1&#39;); }) .then(function(data){ console.log(data); return queryData(&#39;http://localhost:3000/data2&#39;); }) .then(function(data){ console.log(data) }); &lt;/script&gt; Promise 基本API实例方法.then() 得到异步任务正确的结果 .catch() 获取异常信息 .finally() 成功与否都会执行（不是正式标准） &lt;script type=&quot;text/javascript&quot;&gt; /* Promise常用API-实例方法 */ // console.dir(Promise); function foo() { return new Promise(function(resolve, reject){ setTimeout(function(){ // resolve(123); reject(&#39;error&#39;); }, 100); }) } // foo() // .then(function(data){ // console.log(data) // }) // .catch(function(data){ // console.log(data) // }) // .finally(function(){ // console.log(&#39;finished&#39;) // }); // -------------------------- // 两种写法是等效的 foo() .then(function(data){ # 得到异步任务正确的结果 console.log(data) },function(data){ # 获取异常信息 console.log(data) }) # 成功与否都会执行（不是正式标准） .finally(function(){ console.log(&#39;finished&#39;) }); &lt;/script&gt; 静态方法.all() Promise.all方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定 .race() Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数 ​ &lt;script type=&quot;text/javascript&quot;&gt; /* Promise常用API-对象方法 */ // console.dir(Promise) function queryData(url) { return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState != 4) return; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) { // 处理正常的情况 resolve(xhr.responseText); }else{ // 处理异常情况 reject(&#39;服务器错误&#39;); } }; xhr.open(&#39;get&#39;, url); xhr.send(null); }); } var p1 = queryData(&#39;http://localhost:3000/a1&#39;); var p2 = queryData(&#39;http://localhost:3000/a2&#39;); var p3 = queryData(&#39;http://localhost:3000/a3&#39;); Promise.all([p1,p2,p3]).then(function(result){ // all 中的参数 [p1,p2,p3] 和 返回的结果一 一对应[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;] console.log(result) //[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;] }) Promise.race([p1,p2,p3]).then(function(result){ // 由于p1执行较快，Promise的then()将获得结果&#39;P1&#39;。p2,p3仍在继续执行，但执行结果将被丢弃。 console.log(result) // &quot;HELLO TOM&quot; }) &lt;/script&gt; fetch Fetch API是新的ajax解决方案 Fetch会返回Promise fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 fetch(url, options).then(） &lt;script type=&quot;text/javascript&quot;&gt; /* Fetch API 基本用法 fetch(url).then() 第一个参数请求的路径 Fetch会返回Promise 所以我们可以使用then 拿到请求成功的结果 */ fetch(&#39;http://localhost:3000/fdata&#39;).then(function(data){ // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data){ // 在这个then里面我们能拿到最终的数据 console.log(data); }) &lt;/script&gt; fetch API 中的 HTTP 请求 fetch(url, options).then(） HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT 默认的是 GET 请求 需要在 options 对象中 指定对应的 method method:请求使用的方法 post 和 普通 请求的时候 需要在options 中 设置 请求头 headers 和 body &lt;script type=&quot;text/javascript&quot;&gt; /* Fetch API 调用接口传递参数 */ #1.1 GET参数传递 - 传统URL 通过url ？ 的形式传参 fetch(&#39;http://localhost:3000/books?id=123&#39;, { # get 请求可以省略不写 默认的是GET method: &#39;get&#39; }) .then(function(data) { # 它返回一个Promise实例对象，用于获取后台返回的数据 return data.text(); }).then(function(data) { # 在这个then里面我们能拿到最终的数据 console.log(data) }); #1.2 GET参数传递 restful形式的URL 通过/ 的形式传递参数 即 id = 456 和id后台的配置有关 fetch(&#39;http://localhost:3000/books/456&#39;, { # get 请求可以省略不写 默认的是GET method: &#39;get&#39; }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #2.1 DELETE请求方式参数传递 删除id 是 id=789 fetch(&#39;http://localhost:3000/books/789&#39;, { method: &#39;delete&#39; }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); #3 POST请求传参 fetch(&#39;http://localhost:3000/books&#39;, { method: &#39;post&#39;, # 3.1 传递数据 body: &#39;uname=lisi&amp;pwd=123&#39;, # 3.2 设置请求头 headers: { &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # POST请求传参 fetch(&#39;http://localhost:3000/books&#39;, { method: &#39;post&#39;, body: JSON.stringify({ uname: &#39;张三&#39;, pwd: &#39;456&#39; }), headers: { &#39;Content-Type&#39;: &#39;application/json&#39; } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); # PUT请求传参 修改id 是 123 的 fetch(&#39;http://localhost:3000/books/123&#39;, { method: &#39;put&#39;, body: JSON.stringify({ uname: &#39;张三&#39;, pwd: &#39;789&#39; }), headers: { &#39;Content-Type&#39;: &#39;application/json&#39; } }) .then(function(data) { return data.text(); }).then(function(data) { console.log(data) }); &lt;/script&gt; fetchAPI 中 响应格式 用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如JSON，BLOB或者TEXT等等 /* Fetch响应结果的数据格式 */ fetch(&#39;http://localhost:3000/json&#39;).then(function(data){ // return data.json(); // 将获取到的数据使用 json 转换对象 return data.text(); // // 将获取到的数据 转换成字符串 }).then(function(data){ // console.log(data.uname) // console.log(typeof data) var obj = JSON.parse(data); console.log(obj.uname,obj.age,obj.gender) }) axios 基于promise用于浏览器和node.js的http客户端 支持浏览器和node.js 支持promise 能拦截请求和响应 自动转换JSON数据 能转换请求和响应数据 axios基础用法 get和 delete请求传递参数 通过传统的url 以 ? 的形式传递参数 restful 形式传递参数 通过params 形式传递参数 post 和 put 请求传递参数 通过选项传递参数 通过 URLSearchParams 传递参数 # 1. 发送get 请求 axios.get(&#39;http://localhost:3000/adata&#39;).then(function(ret){ # 拿到 ret 是一个对象 所有的对象都存在 ret 的data 属性里面 // 注意data属性是固定的用法，用于获取后台的实际数据 // console.log(ret.data) console.log(ret) }) # 2. get 请求传递参数 # 2.1 通过传统的url 以 ? 的形式传递参数 axios.get(&#39;http://localhost:3000/axios?id=123&#39;).then(function(ret){ console.log(ret.data) }) # 2.2 restful 形式传递参数 axios.get(&#39;http://localhost:3000/axios/123&#39;).then(function(ret){ console.log(ret.data) }) # 2.3 通过params 形式传递参数 axios.get(&#39;http://localhost:3000/axios&#39;, { params: { id: 789 } }).then(function(ret){ console.log(ret.data) }) #3 axios delete 请求传参 传参的形式和 get 请求一样 axios.delete(&#39;http://localhost:3000/axios&#39;, { params: { id: 111 } }).then(function(ret){ console.log(ret.data) }) # 4 axios 的 post 请求 # 4.1 通过选项传递参数 axios.post(&#39;http://localhost:3000/axios&#39;, { uname: &#39;lisi&#39;, pwd: 123 }).then(function(ret){ console.log(ret.data) }) # 4.2 通过 URLSearchParams 传递参数 var params = new URLSearchParams(); params.append(&#39;uname&#39;, &#39;zhangsan&#39;); params.append(&#39;pwd&#39;, &#39;111&#39;); axios.post(&#39;http://localhost:3000/axios&#39;, params).then(function(ret){ console.log(ret.data) }) #5 axios put 请求传参 和 post 请求一样 axios.put(&#39;http://localhost:3000/axios/123&#39;, { uname: &#39;lisi&#39;, pwd: 123 }).then(function(ret){ console.log(ret.data) }) axios 全局配置# 配置公共的请求头 axios.defaults.baseURL = &#39;https://api.example.com&#39;; # 配置 超时时间 axios.defaults.timeout = 2500; # 配置公共的请求头 axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN; # 配置公共的 post 的 Content-Type axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;; axios 拦截器 请求拦截器 请求拦截器的作用是在请求发送前进行一些操作 例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易 响应拦截器 响应拦截器的作用是在接收到响应后进行一些操作 例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页 # 1. 请求拦截器 axios.interceptors.request.use(function(config) { console.log(config.url) # 1.1 任何请求都会经过这一步 在发送请求之前做些什么 config.headers.mytoken = &#39;nihao&#39;; # 1.2 这里一定要return 否则配置不成功 return config; }, function(err){ #1.3 对请求错误做点什么 console.log(err) }) #2. 响应拦截器 axios.interceptors.response.use(function(res) { #2.1 在接收响应做些什么 var data = res.data; return data; }, function(err){ #2.2 对响应错误做点什么 console.log(err) }) async 和 await async作为一个关键字放到函数前面 任何一个async函数都会隐式返回一个promise await关键字只能在使用async定义的函数中使用 ​ await后面可以直接跟一个 Promise实例对象 ​ await函数不能单独使用 async/await 让异步代码看起来、表现起来更像同步代码 # 1. async 基础用法 # 1.1 async作为一个关键字放到函数前面 async function queryData() { # 1.2 await关键字只能在使用async定义的函数中使用 await后面可以直接跟一个 Promise实例对象 var ret = await new Promise(function(resolve, reject){ setTimeout(function(){ resolve(&#39;nihao&#39;) },1000); }) // console.log(ret.data) return ret; } # 1.3 任何一个async函数都会隐式返回一个promise 我们可以使用then 进行链式编程 queryData().then(function(data){ console.log(data) }) #2. async 函数处理多个异步函数 axios.defaults.baseURL = &#39;http://localhost:3000&#39;; async function queryData() { # 2.1 添加await之后 当前的await 返回结果之后才会执行后面的代码 var info = await axios.get(&#39;async1&#39;); #2.2 让异步代码看起来、表现起来更像同步代码 var ret = await axios.get(&#39;async2?info=&#39; + info.data); return ret.data; } queryData().then(function(data){ console.log(data) })","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vue基础学习（三）","slug":"vue3","date":"2020-01-04T11:35:10.000Z","updated":"2020-01-04T11:39:37.842Z","comments":true,"path":"2020/01/04/vue3/","link":"","permalink":"/2020/01/04/vue3/","excerpt":"","text":"组件 组件 (Component) 是 Vue.js 最强大的功能之一 组件可以扩展 HTML 元素，封装可重用的代 组件注册全局注册 Vue.component(‘组件名称’, { }) 第1个参数是标签名称，第2个参数是一个选项对象 全局组件注册后，任何vue实例都可以用 组件基础用&lt;div id=&quot;example&quot;&gt; &lt;!-- 2、 组件使用 组件名称 是以HTML标签的形式使用 --&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; // 注册组件 // 1、 my-component 就是组件中自定义的标签名 Vue.component(&#39;my-component&#39;, { template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39; }) // 创建根实例 new Vue({ el: &#39;#example&#39; }) &lt;/script&gt; 组件注意事项 组件参数的data值必须是函数同时这个函数要求返回一个对象 组件模板必须是单个根元素 组件模板的内容可以是模板字符串 &lt;div id=&quot;app&quot;&gt; &lt;!-- 4、 组件可以重复使用多次 因为data中返回的是一个对象所以每个组件中的数据是私有的 即每个实例可以维护一份被返回对象的独立的拷贝 --&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;!-- 8、必须使用短横线的方式使用组件 --&gt; &lt;hello-world&gt;&lt;/hello-world&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //5 如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件， // 7、但是在普通的标签模板中，必须使用短横线的方式使用组件 Vue.component(&#39;HelloWorld&#39;, { data: function(){ return { msg: &#39;HelloWorld&#39; } }, template: &#39;&lt;div&gt;{{msg}}&lt;/div&gt;&#39; }); Vue.component(&#39;button-counter&#39;, { // 1、组件参数的data值必须是函数 // 同时这个函数要求返回一个对象 data: function(){ return { count: 0 } }, // 2、组件模板必须是单个根元素 // 3、组件模板的内容可以是模板字符串 template: ` &lt;div&gt; &lt;button @click=&quot;handle&quot;&gt;点击了{{count}}次&lt;/button&gt; &lt;button&gt;测试123&lt;/button&gt; # 6 在字符串模板中可以使用驼峰的方式使用组件 &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt; `, methods: { handle: function(){ this.count += 2; } } }) var vm = new Vue({ el: &#39;#app&#39;, data: { } }); &lt;/script&gt; 局部注册 只能在当前注册它的vue实例中使用 &lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; // 定义组件的模板 var Child = { template: &#39;&lt;div&gt;A custom component!&lt;/div&gt;&#39; } new Vue({ //局部注册组件 components: { // &lt;my-component&gt; 将只在父模板可用 一定要在实例上注册了才能在html文件中使用 &#39;my-component&#39;: Child } }) &lt;/script&gt; Vue组件之间传值父组件向子组件传值 父组件发送的形式是以属性的形式绑定值到子组件身上。 然后子组件用属性props接收 在props中使用驼峰形式，模板中需要使用短横线的形式字符串形式的模板中没有这个限制 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{pmsg}}&lt;/div&gt; &lt;!--1、menu-item 在 APP中嵌套着 故 menu-item 为 子组件 --&gt; &lt;!-- 给子组件传入一个静态的值 --&gt; &lt;menu-item title=&#39;来自父组件的值&#39;&gt;&lt;/menu-item&gt; &lt;!-- 2、 需要动态的数据的时候 需要属性绑定的形式设置 此时 ptitle 来自父组件data 中的数据 . 传的值可以是数字、对象、数组等等 --&gt; &lt;menu-item :title=&#39;ptitle&#39; content=&#39;hello&#39;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#39;menu-item&#39;, { // 3、 子组件用属性props接收父组件传递过来的数据 props: [&#39;title&#39;, &#39;content&#39;], data: function() { return { msg: &#39;子组件本身的数据&#39; } }, template: &#39;&lt;div&gt;{{msg + \"----\" + title + \"-----\" + content}}&lt;/div&gt;&#39; }); var vm = new Vue({ el: &#39;#app&#39;, data: { pmsg: &#39;父组件中内容&#39;, ptitle: &#39;动态绑定属性&#39; } }); &lt;/script&gt; 子组件向父组件传值 子组件用$emit()触发事件 $emit() 第一个参数为 自定义的事件名称 第二个参数为需要传递的数据 父组件用v-on 监听子组件的事件 &lt;div id=&quot;app&quot;&gt; &lt;div :style=&#39;{fontSize: fontSize + &quot;px&quot;}&#39;&gt;{{pmsg}}&lt;/div&gt; &lt;!-- 2 父组件用v-on 监听子组件的事件 这里 enlarge-text 是从 $emit 中的第一个参数对应 handle 为对应的事件处理函数 --&gt; &lt;menu-item :parr=&#39;parr&#39; @enlarge-text=&#39;handle($event)&#39;&gt;&lt;/menu-item&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 子组件向父组件传值-携带参数 */ Vue.component(&#39;menu-item&#39;, { props: [&#39;parr&#39;], template: ` &lt;div&gt; &lt;ul&gt; &lt;li :key=&#39;index&#39; v-for=&#39;(item,index) in parr&#39;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; ### 1、子组件用$emit()触发事件 ### 第一个参数为 自定义的事件名称 第二个参数为需要传递的数据 &lt;button @click=&#39;$emit(&quot;enlarge-text&quot;, 5)&#39;&gt;扩大父组件中字体大小&lt;/button&gt; &lt;button @click=&#39;$emit(&quot;enlarge-text&quot;, 10)&#39;&gt;扩大父组件中字体大小&lt;/button&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: &#39;#app&#39;, data: { pmsg: &#39;父组件中内容&#39;, parr: [&#39;apple&#39;,&#39;orange&#39;,&#39;banana&#39;], fontSize: 10 }, methods: { handle: function(val){ // 扩大字体大小 this.fontSize += val; } } }); &lt;/script&gt; 兄弟之间的传递 兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据 提供事件中心 var hub = new Vue() 传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;div&gt; &lt;button @click=&#39;handle&#39;&gt;销毁事件&lt;/button&gt; &lt;/div&gt; &lt;test-tom&gt;&lt;/test-tom&gt; &lt;test-jerry&gt;&lt;/test-jerry&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 兄弟组件之间数据传递 */ //1、 提供事件中心 var hub = new Vue(); Vue.component(&#39;test-tom&#39;, { data: function(){ return { num: 0 } }, template: ` &lt;div&gt; &lt;div&gt;TOM:{{num}}&lt;/div&gt; &lt;div&gt; &lt;button @click=&#39;handle&#39;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { handle: function(){ //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 触发兄弟组件的事件 hub.$emit(&#39;jerry-event&#39;, 2); } }, mounted: function() { // 3、接收数据方，通过mounted(){} 钩子中 触发hub.$on(方法名 hub.$on(&#39;tom-event&#39;, (val) =&gt; { this.num += val; }); } }); Vue.component(&#39;test-jerry&#39;, { data: function(){ return { num: 0 } }, template: ` &lt;div&gt; &lt;div&gt;JERRY:{{num}}&lt;/div&gt; &lt;div&gt; &lt;button @click=&#39;handle&#39;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; `, methods: { handle: function(){ //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据) 触发兄弟组件的事件 hub.$emit(&#39;tom-event&#39;, 1); } }, mounted: function() { // 3、接收数据方，通过mounted(){} 钩子中 触发hub.$on()方法名 hub.$on(&#39;jerry-event&#39;, (val) =&gt; { this.num += val; }); } }); var vm = new Vue({ el: &#39;#app&#39;, data: { }, methods: { handle: function(){ //4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据 hub.$off(&#39;tom-event&#39;); hub.$off(&#39;jerry-event&#39;); } } }); &lt;/script&gt; 组件插槽 组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力 匿名插槽 &lt;div id=&quot;app&quot;&gt; &lt;!-- 这里的所有组件标签中嵌套的内容会替换掉slot 如果不传值 则使用 slot 中的默认值 --&gt; &lt;alert-box&gt;有bug发生&lt;/alert-box&gt; &lt;alert-box&gt;有一个警告&lt;/alert-box&gt; &lt;alert-box&gt;&lt;/alert-box&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 组件插槽：父组件向子组件传递内容 */ Vue.component(&#39;alert-box&#39;, { template: ` &lt;div&gt; &lt;strong&gt;ERROR:&lt;/strong&gt; # 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“组件标签中嵌套的内容”。 # 插槽内可以包含任何模板代码，包括 HTML &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: &#39;#app&#39;, data: { } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 具名插槽 具有名字的插槽 使用 中的 “name” 属性绑定元素 &lt;div id=&quot;app&quot;&gt; &lt;base-layout&gt; &lt;!-- 2、 通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上 如果没有匹配到 则放到匿名的插槽中 --&gt; &lt;p slot=&#39;header&#39;&gt;标题信息&lt;/p&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;p slot=&#39;footer&#39;&gt;底部信息信息&lt;/p&gt; &lt;/base-layout&gt; &lt;base-layout&gt; &lt;!-- 注意点：template临时的包裹标签最终不会渲染到页面上 --&gt; &lt;template slot=&#39;header&#39;&gt; &lt;p&gt;标题信息1&lt;/p&gt; &lt;p&gt;标题信息2&lt;/p&gt; &lt;/template&gt; &lt;p&gt;主要内容1&lt;/p&gt; &lt;p&gt;主要内容2&lt;/p&gt; &lt;template slot=&#39;footer&#39;&gt; &lt;p&gt;底部信息信息1&lt;/p&gt; &lt;p&gt;底部信息信息2&lt;/p&gt; &lt;/template&gt; &lt;/base-layout&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 具名插槽 */ Vue.component(&#39;base-layout&#39;, { template: ` &lt;div&gt; &lt;header&gt; ### 1、 使用 &lt;slot&gt; 中的 &quot;name&quot; 属性绑定元素 指定当前插槽的名字 &lt;slot name=&#39;header&#39;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; ### 注意点： ### 具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序 &lt;slot name=&#39;footer&#39;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: &#39;#app&#39;, data: { } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 作用域插槽 父组件对子组件加工处理 既可以复用子组件的slot，又可以使slot内容不一致 &lt;div id=&quot;app&quot;&gt; &lt;!-- 1、当我们希望li 的样式由外部使用组件的地方定义，因为可能有多种地方要使用该组件， 但样式希望不一样 这个时候我们需要使用作用域插槽 --&gt; &lt;fruit-list :list=&#39;list&#39;&gt; &lt;!-- 2、 父组件中使用了&lt;template&gt;元素,而且包含scope=&quot;slotProps&quot;, slotProps在这里只是临时变量 ---&gt; &lt;template slot-scope=&#39;slotProps&#39;&gt; &lt;strong v-if=&#39;slotProps.info.id==3&#39; class=&quot;current&quot;&gt; {{slotProps.info.name}} &lt;/strong&gt; &lt;span v-else&gt;{{slotProps.info.name}}&lt;/span&gt; &lt;/template&gt; &lt;/fruit-list&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 作用域插槽 */ Vue.component(&#39;fruit-list&#39;, { props: [&#39;list&#39;], template: ` &lt;div&gt; &lt;li :key=&#39;item.id&#39; v-for=&#39;item in list&#39;&gt; ### 3、 在子组件模板中,&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg=&quot;xxx&quot;, ### 插槽可以提供一个默认内容，如果如果父组件没有为这个插槽提供了内容，会显示默认的内容。 如果父组件为这个插槽提供了内容，则默认的内容会被替换掉 &lt;slot :info=&#39;item&#39;&gt;{{item.name}}&lt;/slot&gt; &lt;/li&gt; &lt;/div&gt; ` }); var vm = new Vue({ el: &#39;#app&#39;, data: { list: [{ id: 1, name: &#39;apple&#39; },{ id: 2, name: &#39;orange&#39; },{ id: 3, name: &#39;banana&#39; }] } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vue基础学习（二）","slug":"vue2","date":"2020-01-04T11:31:49.000Z","updated":"2020-01-04T11:32:59.982Z","comments":true,"path":"2020/01/04/vue2/","link":"","permalink":"/2020/01/04/vue2/","excerpt":"","text":"Vue常用特性表单基本操作 获取单选框中的值 通过v-model &lt;!-- 1、 两个单选框需要同时通过v-model 双向绑定 一个值 2、 每一个单选框必须要有value属性 且value 值不能一样 3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 gender 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt; &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;1&quot; v-model=&#39;gender&#39;&gt; &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;2&quot; v-model=&#39;gender&#39;&gt; &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt; &lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 的单选框选中 gender: 2, }, }) &lt;/script&gt; 获取复选框中的值 通过v-model 和获取单选框中的值一样 复选框 checkbox 这种的组合时 data 中的 hobby 我们要定义成数组 否则无法实现多选 &lt;!-- 1、 复选框需要同时通过v-model 双向绑定 一个值 2、 每一个复选框必须要有value属性 且value 值不能一样 3、 当某一个单选框选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 hobby 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt; &lt;div&gt; &lt;span&gt;爱好：&lt;/span&gt; &lt;input type=&quot;checkbox&quot; id=&quot;ball&quot; value=&quot;1&quot; v-model=&#39;hobby&#39;&gt; &lt;label for=&quot;ball&quot;&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;sing&quot; value=&quot;2&quot; v-model=&#39;hobby&#39;&gt; &lt;label for=&quot;sing&quot;&gt;唱歌&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;code&quot; value=&quot;3&quot; v-model=&#39;hobby&#39;&gt; &lt;label for=&quot;code&quot;&gt;写代码&lt;/label&gt; &lt;/div&gt; &lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 和 3 的复选框选中 hobby: [&#39;2&#39;, &#39;3&#39;], }, }) &lt;/script&gt; 获取下拉框和文本框中的值 通过v-model &lt;div&gt; &lt;span&gt;职业：&lt;/span&gt; &lt;!-- 1、 需要给select 通过v-model 双向绑定 一个值 2、 每一个option 必须要有value属性 且value 值不能一样 3、 当某一个option选中的时候 v-model 会将当前的 value值 改变 data 中的 数据 occupation 的值就是选中的值，我们只需要实时监控他的值就可以了 --&gt; &lt;!-- multiple 多选 --&gt; &lt;select v-model=&#39;occupation&#39; multiple&gt; &lt;option value=&quot;0&quot;&gt;请选择职业...&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;教师&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;软件工程师&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;律师&lt;/option&gt; &lt;/select&gt; &lt;!-- textarea 是 一个双标签 不需要绑定value 属性的 --&gt; &lt;textarea v-model=&#39;desc&#39;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script&gt; new Vue({ data: { // 默认会让当前的 value 值为 2 和 3 的下拉框选中 occupation: [&#39;2&#39;, &#39;3&#39;], desc: &#39;nihao&#39; }, }) &lt;/script&gt; 表单修饰符 .number 转换为数值 注意点： 当开始输入非数字的字符串时，因为Vue无法将字符串转换成数值 所以属性值将实时更新成相同的字符串。即使后面输入数字，也将被视作字符串。 .trim 自动过滤用户输入的首尾空白字符 只能去掉首尾的 不能去除中间的空格 .lazy 将input事件切换成change事件 .lazy 修饰符延迟了同步更新属性值的时机。即将原本绑定在 input 事件的同步逻辑转变为绑定在 change 事件上 在失去焦点 或者 按下回车键时才更新 &lt;!-- 自动将用户的输入值转为数值类型 --&gt; &lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; &lt;!--自动过滤用户输入的首尾空白字符 --&gt; &lt;input v-model.trim=&quot;msg&quot;&gt; &lt;!-- 在“change”时而非“input”时更新 --&gt; &lt;input v-model.lazy=&quot;msg&quot; &gt; 自定义指令 内置指令不能满足我们特殊的需求 Vue允许我们自定义指令 Vue.directive 注册全局指令&lt;!-- 使用自定义的指令，只需在对用的元素中，加上&#39;v-&#39;的前缀形成类似于内部指令&#39;v-if&#39;，&#39;v-text&#39;的形式。 --&gt; &lt;input type=&quot;text&quot; v-focus&gt; &lt;script&gt; // 注意点： // 1、 在自定义指令中 如果以驼峰命名的方式定义 如 Vue.directive(&#39;focusA&#39;,function(){}) // 2、 在HTML中使用的时候 只能通过 v-focus-a 来使用 // 注册一个全局自定义指令 v-focus Vue.directive(&#39;focus&#39;, { // 当绑定元素插入到 DOM 中。 其中 el为dom元素 inserted: function (el) { // 聚焦元素 el.focus(); } }); new Vue({ el:&#39;#app&#39; }); &lt;/script&gt; Vue.directive 注册全局指令 带参数 &lt;input type=&quot;text&quot; v-color=&#39;msg&#39;&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 自定义指令-带参数 bind - 只调用一次，在指令第一次绑定到元素上时候调用 */ Vue.directive(&#39;color&#39;, { // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 // el 为当前自定义指令的DOM元素 // binding 为自定义的函数形参 通过自定义属性传递过来的值 存在 binding.value 里面 bind: function(el, binding){ // 根据指令的参数设置背景色 // console.log(binding.value.color) el.style.backgroundColor = binding.value.color; } }); var vm = new Vue({ el: &#39;#app&#39;, data: { msg: { color: &#39;blue&#39; } } }); &lt;/script&gt; 自定义指令局部指令 局部指令，需要定义在 directives 的选项 用法和全局用法一样 局部指令只能在当前组件里面使用 当全局指令和局部指令同名时以局部指令为准 &lt;input type=&quot;text&quot; v-color=&#39;msg&#39;&gt; &lt;input type=&quot;text&quot; v-focus&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 自定义指令-局部指令 */ var vm = new Vue({ el: &#39;#app&#39;, data: { msg: { color: &#39;red&#39; } }, //局部指令，需要定义在 directives 的选项 directives: { color: { bind: function(el, binding){ el.style.backgroundColor = binding.value.color; } }, focus: { inserted: function(el) { el.focus(); } } } }); &lt;/script&gt; 计算属性 computed 模板中放入太多的逻辑会让模板过重且难以维护 使用计算属性可以让模板更加的简洁 计算属性是基于它们的响应式依赖进行缓存的 computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化 &lt;div id=&quot;app&quot;&gt; &lt;!-- 当多次调用 reverseString 的时候 只要里面的 num 值不改变 他会把第一次计算的结果直接返回 直到data 中的num值改变 计算属性才会重新发生计算 --&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;div&gt;{{reverseString}}&lt;/div&gt; &lt;!-- 调用methods中的方法的时候 他每次会重新调用 --&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;div&gt;{{reverseMessage()}}&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存 */ var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Nihao&#39;, num: 100 }, methods: { reverseMessage: function(){ console.log(&#39;methods&#39;) return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;); } }, //computed 属性 定义 和 data 已经 methods 平级 computed: { // reverseString 这个是我们自己定义的名字 reverseString: function(){ console.log(&#39;computed&#39;) var total = 0; // 当data 中的 num 的值改变的时候 reverseString 会自动发生计算 for(var i=0;i&lt;=this.num;i++){ total += i; } // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果 return total; } } }); &lt;/script&gt; 侦听器 watch 使用watch来响应数据的变化 一般用于异步或者开销较大的操作 watch 中的属性 一定是data 中 已经存在的数据 当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听 &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;名：&lt;/span&gt; &lt;span&gt; &lt;input type=&quot;text&quot; v-model=&#39;firstName&#39;&gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;姓：&lt;/span&gt; &lt;span&gt; &lt;input type=&quot;text&quot; v-model=&#39;lastName&#39;&gt; &lt;/span&gt; &lt;/div&gt; &lt;div&gt;{{fullName}}&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 侦听器 */ var vm = new Vue({ el: &#39;#app&#39;, data: { firstName: &#39;Jim&#39;, lastName: &#39;Green&#39;, // fullName: &#39;Jim Green&#39; }, //watch 属性 定义 和 data 已经 methods 平级 watch: { // 注意： 这里firstName 对应着data 中的 firstName // 当 firstName 值 改变的时候 会自动触发 watch firstName: function(val) { this.fullName = val + &#39; &#39; + this.lastName; }, // 注意： 这里 lastName 对应着data 中的 lastName lastName: function(val) { this.fullName = this.firstName + &#39; &#39; + val; } } }); &lt;/script&gt; 过滤器 Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。 过滤器可以用在两个地方：双花括号插值和v-bind表达式。 过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示 支持级联操作 过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本 全局注册时是filter，没有s的。而局部过滤器是filters，是有s的 &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt; &lt;!-- upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 --&gt; &lt;div&gt;{{msg | upper}}&lt;/div&gt; &lt;!-- 支持级联操作 upper 被定义为接收单个参数的过滤器函数，表达式msg 的值将作为参数传入到函数中。 然后继续调用同样被定义为接收单个参数的过滤器 lower ，将upper 的结果传递到lower中 --&gt; &lt;div&gt;{{msg | upper | lower}}&lt;/div&gt; &lt;div :abc=&#39;msg | upper&#39;&gt;测试数据&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // lower 为全局过滤器 Vue.filter(&#39;lower&#39;, function(val) { return val.charAt(0).toLowerCase() + val.slice(1); }); var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;&#39; }, //filters 属性 定义 和 data 已经 methods 平级 // 定义filters 中的过滤器为局部过滤器 filters: { // upper 自定义的过滤器名字 // upper 被定义为接收单个参数的过滤器函数，表达式 msg 的值将作为参数传入到函数中 upper: function(val) { // 过滤器中一定要有返回值 这样外界使用过滤器的时候才能拿到结果 return val.charAt(0).toUpperCase() + val.slice(1); } } }); &lt;/script&gt; 过滤器中传递参数 &lt;div id=&quot;box&quot;&gt; &lt;!-- filterA 被定义为接收三个参数的过滤器函数。 其中 message 的值作为第一个参数， 普通字符串 &#39;arg1&#39; 作为第二个参数，表达式 arg2 的值作为第三个参数。 --&gt; {{ message | filterA('arg1', 'arg2') }} &lt;/div&gt; &lt;script&gt; // 在过滤器中 第一个参数 对应的是 管道符前面的数据 n 此时对应 message // 第2个参数 a 对应 实参 arg1 字符串 // 第3个参数 b 对应 实参 arg2 字符串 Vue.filter(&#39;filterA&#39;,function(n,a,b){ if(n&lt;10){ return n+a; }else{ return n+b; } }); new Vue({ el:&quot;#box&quot;, data:{ message: &quot;哈哈哈&quot; } }) &lt;/script&gt; 生命周期 事物从出生到死亡的过程 Vue实例从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数 ####常用的 钩子函数 beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化 什么都做不了 created 在实例创建完成后被立即调用此时data 和 methods已经可以使用 但是页面还没有渲染出来 beforeMount 在挂载开始之前被调用 此时页面上还看不到真实数据 只是一个模板页面而已 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 数据已经真实渲染到页面上 在这个钩子函数里面我们可以使用一些第三方的插件 beforeUpdate 数据更新时调用，发生在虚拟DOM打补丁之前。 页面上数据还是旧的 updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的 beforeDestroy 实例销毁之前调用 destroyed 实例销毁后调用 数组变异方法 在 Vue 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变 变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展 push() 往数组最后面添加一个元素，成功返回当前数组的长度 pop() 删除数组的最后一个元素，成功返回删除元素的值 shift() 删除数组的第一个元素，成功返回删除元素的值 unshift() 往数组最前面添加一个元素，成功返回当前数组的长度 splice() 有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除 后想要在原位置替换的值 sort() sort() 使数组按照字符编码默认从小到大排序,成功返回排序后的数组 reverse() reverse() 将数组倒序，成功返回倒序后的数组 替换数组 不会改变原始数组，但总是返回一个新数组 filter filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 concat concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组 slice slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组 动态数组响应式数据 Vue.set(a,b,c) 让 触发视图重新更新一遍，数据动态起来 a是要更改的数据 、 b是数据的第几项、 c是更改后的数据","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"vue基础学习（一）","slug":"vue1","date":"2020-01-04T11:13:49.000Z","updated":"2020-01-04T11:34:41.971Z","comments":true,"path":"2020/01/04/vue1/","link":"","permalink":"/2020/01/04/vue1/","excerpt":"","text":"Vue 是什么？ Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架 vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合 指令 本质就是自定义属性 Vue中指定都是以 v- 开头 v-cloak 防止页面加载时出现闪烁问题 &lt;style type=&quot;text/css&quot;&gt; /* 1、通过属性选择器 选择到 带有属性 v-cloak的标签 让他隐藏 */ [v-cloak]{ /* 元素隐藏 */ display: none; } &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 2、 让带有插值 语法的 添加 v-cloak 属性 在 数据渲染完场之后，v-cloak 属性会被自动去除， v-cloak一旦移除也就是没有这个属性了 属性选择器就选择不到该标签 也就是对应的标签会变为可见 --&gt; &lt;div v-cloak &gt;{{msg}}&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ // el 指定元素 id 是 app 的元素 el: &#39;#app&#39;, // data 里面存储的是数据 data: { msg: &#39;Hello Vue&#39; } }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; v-text v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题 如果数据中有HTML标签会将html标签一并输出 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值 &lt;div id=&quot;app&quot;&gt; &lt;!-- 注意:在指令中不要写插值语法 直接写对应的变量名称 在 v-text 中 赋值的时候不要在写 插值语法 一般属性中不加 {{}} 直接写 对应 的数据名 --&gt; &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt; &lt;p&gt; &lt;!-- Vue 中只有在标签的 内容中 才用插值语法 --&gt; {{msg}} &lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue.js&#39; } }); &lt;/script&gt; v-html 用法和v-text 相似 但是他可以将HTML片段填充到标签中 可能有安全问题, 一般只在可信任内容上使用 v-html，永不用在用户提交的内容上 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。 &lt;div id=&quot;app&quot;&gt; &lt;p v-html=&quot;html&quot;&gt;&lt;/p&gt; &lt;!-- 输出：html标签在渲染的时候被解析 --&gt; &lt;p&gt;{{message}}&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;通过双括号绑定&lt;/span&gt; --&gt; &lt;p v-text=&quot;text&quot;&gt;&lt;/p&gt; &lt;!-- 输出：&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt; --&gt; &lt;/div&gt; &lt;script&gt; let app = new Vue({ el: &quot;#app&quot;, data: { message: &quot;&lt;span&gt;通过双括号绑定&lt;/span&gt;&quot;, html: &quot;&lt;span&gt;html标签在渲染的时候被解析&lt;/span&gt;&quot;, text: &quot;&lt;span&gt;html标签在渲染的时候被源码输出&lt;/span&gt;&quot;, } }); &lt;/script&gt; v-pre 显示原始信息跳过编译过程 跳过这个元素和它的子元素的编译过程。 一些静态的内容不需要编译加这个指令可以加快渲染 &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt; &lt;!-- 显示的是{{ this will not be compiled }} --&gt; &lt;span v-pre&gt;{{msg}}&lt;/span&gt; &lt;!-- 即使data里面定义了msg这里仍然是显示的{{msg}} --&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue.js&#39; } }); &lt;/script&gt; v-once 执行一次性的插值【当数据改变时，插值处的内容不会继续更新】 &lt;!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js --&gt; &lt;span v-once&gt;{{ msg}}&lt;/span&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue.js&#39; } }); &lt;/script&gt; 双向数据绑定 当数据发生变化的时候，视图也就发生变化 当视图发生变化的时候，数据也会跟着同步变化 v-model v-model是一个指令，限制在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;、components中使用 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;div&gt; 当输入框中内容改变的时候， 页面上的msg 会自动更新 &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt; &lt;/div&gt; &lt;/div&gt; mvvm MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel m model 数据层 Vue 中 数据层 都放在 data 里面 v view 视图 Vue 中 view 即 我们的HTML页面 vm （view-model） 控制器 将数据和视图层建立联系 vm 即 Vue 的实例 就是 vm v-on 用来绑定事件的 形式如：v-on:click 缩写为 @click; v-on事件函数中传入参数 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{num}}&lt;/div&gt; &lt;div&gt; &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt; &lt;button v-on:click=&#39;handle1&#39;&gt;点击1&lt;/button&gt; &lt;!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递， 并且事件对象的名称必须是$event --&gt; &lt;button v-on:click=&#39;handle2(123, 456, $event)&#39;&gt;点击2&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML) }, handle2: function(p, p1, event) { console.log(p, p1) console.log(event.target.innerHTML) this.num++; } } }); &lt;/script&gt; 事件修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。 Vue 不推荐我们操作DOM 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符 修饰符是由点开头的指令后缀来表示的 &lt;!-- 阻止单击事件继续传播 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 即阻止冒泡也阻止默认事件 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt; &lt;!-- 即事件不是从内部元素触发的 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 按键修饰符 在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符 &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.13=&quot;submit&quot;&gt; &lt;!-- -当点击enter 时调用 `vm.submit()` --&gt; &lt;input v-on:keyup.enter=&quot;submit&quot;&gt; &lt;!--当点击enter或者space时 时调用 `vm.alertMe()` --&gt; &lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt; 常用的按键修饰符 .enter =&gt; enter键 .tab =&gt; tab键 .delete (捕获“删除”和“退格”按键) =&gt; 删除键 .esc =&gt; 取消键 .space =&gt; 空格键 .up =&gt; 上 .down =&gt; 下 .left =&gt; 左 .right =&gt; 右 &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, methods: { submit:function(){}, alertMe:function(){}, } }) &lt;/script&gt; 自定义按键修饰符别名 在Vue中可以通过config.keyCodes自定义按键修饰符别名 &lt;div id=&quot;app&quot;&gt; 预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法 &lt;input type=&quot;text&quot; v-on:keydown.f5=&quot;prompt()&quot;&gt; &lt;/div&gt; &lt;script&gt; Vue.config.keyCodes.f5 = 116; let app = new Vue({ el: &#39;#app&#39;, methods: { prompt: function() { alert(&#39;我是 F5！&#39;); } } }); &lt;/script&gt; v-bind v-bind 指令被用来响应地更新 HTML 属性 v-bind:href 可以缩写为 :href; &lt;!-- 绑定一个属性 --&gt; &lt;img v-bind:src=&quot;imageSrc&quot;&gt; &lt;!-- 缩写 --&gt; &lt;img :src=&quot;imageSrc&quot;&gt; 绑定对象 我们可以给v-bind:class 一个对象，以动态地切换class。 注意：v-bind:class指令可以与普通的class特性共存 1、 v-bind 中支持绑定一个对象 如果绑定的是一个对象 则 键为 对应的类名 值 为对应data中的数据 &lt;!-- HTML最终渲染为 &lt;ul class=&quot;box textColor textSize&quot;&gt;&lt;/ul&gt; 注意： textColor，textSize 对应的渲染到页面上的CSS类名 isColor，isSize 对应vue data中的数据 如果为true 则对应的类名 渲染到页面上 当 isColor 和 isSize 变化时，class列表将相应的更新， 例如，将isSize改成false， class列表将变为 &lt;ul class=&quot;box textColor&quot;&gt;&lt;/ul&gt; --&gt; &lt;ul class=&quot;box&quot; v-bind:class=&quot;{textColor:isColor, textSize:isSize}&quot;&gt; &lt;li&gt;学习Vue&lt;/li&gt; &lt;li&gt;学习Node&lt;/li&gt; &lt;li&gt;学习React&lt;/li&gt; &lt;/ul&gt; &lt;div v-bind:style=&quot;{color:activeColor,fontSize:activeSize}&quot;&gt;对象语法&lt;/div&gt; &lt;sript&gt; var vm= new Vue({ el:&#39;.box&#39;, data:{ isColor:true, isSize:true， activeColor:&quot;red&quot;, activeSize:&quot;25px&quot;, } }) &lt;/sript&gt; &lt;style&gt; .box{ border:1px dashed #f0f; } .textColor{ color:#f00; background-color:#eef; } .textSize{ font-size:30px; font-weight:bold; } &lt;/style&gt; 绑定class2、 v-bind 中支持绑定一个数组 数组中classA和 classB 对应为data中的数据 这里的classA 对用data 中的 classA 这里的classB 对用data 中的 classB &lt;ul class=&quot;box&quot; :class=&quot;[classA, classB]&quot;&gt; &lt;li&gt;学习Vue&lt;/li&gt; &lt;li&gt;学习Node&lt;/li&gt; &lt;li&gt;学习React&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var vm= new Vue({ el:&#39;.box&#39;, data:{ classA:‘textColor‘, classB:‘textSize‘ } }) &lt;/script&gt; &lt;style&gt; .box{ border:1px dashed #f0f; } .textColor{ color:#f00; background-color:#eef; } .textSize{ font-size:30px; font-weight:bold; } &lt;/style&gt; 绑定对象和绑定数组 的区别 绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 绑定数组的时候数组里面存的是data 中的数据 绑定style &lt;div v-bind:style=&quot;styleObject&quot;&gt;绑定样式对象&lt;/div&gt;&#39; &lt;!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) --&gt; &lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize,background:&#39;red&#39; }&quot;&gt;内联样式&lt;/div&gt; &lt;!--组语法可以将多个样式对象应用到同一个元素 --&gt; &lt;div v-bind:style=&quot;[styleObj1, styleObj2]&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data: { styleObject: { color: &#39;green&#39;, fontSize: &#39;30px&#39;, background:&#39;red&#39; }， activeColor: &#39;green&#39;, fontSize: &quot;30px&quot; }, styleObj1: { color: &#39;red&#39; }, styleObj2: { fontSize: &#39;30px&#39; } &lt;/script&gt; 分支结构v-if 使用场景 1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素 2- 进行两个视图之间的切换 &lt;div id=&quot;app&quot;&gt; &lt;!-- 判断是否加载，如果为真，就加载，否则不加载--&gt; &lt;span v-if=&quot;flag&quot;&gt; 如果flag为true则显示,false不显示! &lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el:&quot;#app&quot;, data:{ flag:true } }) &lt;/script&gt; ---------------------------------------------------------- &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt; A &lt;/div&gt; &lt;!-- v-else-if紧跟在v-if或v-else-if之后 表示v-if条件不成立时执行--&gt; &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt; C &lt;/div&gt; &lt;!-- v-else紧跟在v-if或v-else-if之后--&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt; &lt;script&gt; new Vue({ el: &#39;#app&#39;, data: { type: &#39;C&#39; } }) &lt;/script&gt; v-show 和 v-if的区别 v-show本质就是标签display设置为none，控制隐藏 v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。 v-if是动态的向DOM树内添加或者删除DOM元素 v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 循环结构v-for 用于循环的数组里面的值可以是对象，也可以是普通元素 &lt;ul id=&quot;example-1&quot;&gt; &lt;!-- 循环结构-遍历数组 item 是我们自己定义的一个名字 代表数组里面的每一项 items对应的是 data中的数组--&gt; &lt;li v-for=&quot;item in items&quot;&gt; {{ item.message }} &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; new Vue({ el: &#39;#example-1&#39;, data: { items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ]， } }) &lt;/script&gt; 不推荐同时使用 v-if 和 v-for 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 &lt;!-- 循环结构-遍历对象 v 代表 对象的value k 代表对象的 键 i 代表索引 ---&gt; &lt;div v-if=&#39;v==13&#39; v-for=&#39;(v,k,i) in obj&#39;&gt;{{v + '---' + k + '---' + i}}&lt;/div&gt; &lt;script&gt; new Vue({ el: &#39;#example-1&#39;, data: { items: [ { message: &#39;Foo&#39; }, { message: &#39;Bar&#39; } ]， obj: { uname: &#39;zhangsan&#39;, age: 13, gender: &#39;female&#39; } } }) &lt;/script&gt; key 的作用 key来给每个节点做一个唯一标识 key的作用主要是为了高效的更新虚拟DOM &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt; &lt;/ul&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"AJAX学习第四天","slug":"ajax4","date":"2019-12-21T12:46:31.000Z","updated":"2019-12-21T12:55:47.123Z","comments":true,"path":"2019/12/21/ajax4/","link":"","permalink":"/2019/12/21/ajax4/","excerpt":"","text":"Jquery 中的Ajax$.ajax()### 方法的概述： ​ 作用1: 发送Ajax请求。 $.ajax({ type: &#39;get&#39;, url: &#39;http://www.example.com&#39;, data: { name: &#39;zhangsan&#39;, age: &#39;20&#39; }, contentType: &#39;application/x-www-form-urlencoded&#39;, beforeSend: function () { return false }, success: function (response) {}, error: function (xhr) {} }); ​作用2: 发送jsonp请求。 $.ajax({ url: &#39;http://www.example.com&#39;, // 指定当前发送jsonp请求 dataType: &#39;jsonp&#39;, // 修改callback参数名称 jsonp: &#39;cb&#39;, // 指定函数名称 jsonCallback: &#39;fnName&#39;, success: function (response) {} }) ​ serialize方法作用：将表单中的数据自动拼接成字符串类型的参数 var params = $(&#39;#form&#39;).serialize(); // name=zhangsan&amp;age=30 $.get作用: 用于发送get请求 $.get(&#39;http://www.example.com&#39;, {name: &#39;zhangsan&#39;, age: 30}, function (response) {}) $.post作用: 用于发送post请求 $.post(&#39;http://www.example.com&#39;, {name: &#39;lisi&#39;, age: 22}, function (response) {})","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"AJAX学习第三天","slug":"ajax3","date":"2019-12-21T12:33:00.000Z","updated":"2019-12-21T12:55:13.939Z","comments":true,"path":"2019/12/21/ajax3/","link":"","permalink":"/2019/12/21/ajax3/","excerpt":"","text":"同源政策Ajax请求限制Ajax 只能向自己的服务器发送请求。 比如现在有一个A网站、有一个B网站，A网站中的 HTML 文件只能向A网站服务器中发送 Ajax 请求，B网站中的 HTML 文件只能向 B 网站中发送 Ajax 请求，但是 A 网站是不能向 B 网站发送 Ajax请求的，同理，B 网站也不能向 A 网站发送 Ajax请求。 什么是同源如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。 http://www.example.com/dir/page.html http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） https://www.example.com/dir/page.html：不同源（协议不同） 同源政策的目的同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指A 网站在客户端设置的 Cookie，B网站是不能访问的。 随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 使用 JSONP 解决同源限制问题jsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求。 将不同源的服务器端请求地址写在 script 标签的 src 属性中。 &lt;script src=&quot;www.example.com&quot;&gt;&lt;/script&gt; &lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 const data = &#39;fn({name: &quot;张三&quot;, age: &quot;20&quot;})&#39;; res.send(data); 在客户端全局作用域下定义函数 fn。 function fn (data) { } 在 fn 函数内部对服务器端返回的数据进行处理。 function fn (data) { console.log(data); } JSONP 代码优化 客户端需要将函数名称传递到服务器端。 将 script 请求的发送变成动态请求。 // 为按钮添加点击事件 btn.onclick = function () { // 创建script标签 var script = document.createElement(&#39;script&#39;); // 设置src属性 script.src = &#39;http://localhost:3001/better?callback=fn2&#39;; // 将script标签追加到页面中 document.body.appendChild(script); // 为script标签添加onload事件 script.onload = function () { // 将body中的script标签删除掉 document.body.removeChild(script); } } 封装 jsonp 函数，方便请求发送。 function jsonp (options){ // 动态创建 script 标签 var script = document.createElement(&#39;script&#39;) // 为script标签 添加src属性 script.src = options.url; // 将 script 标签追加到页面上 document.body.appendChild(script); // 为script 标签添加onload事件 script.onload = function () { document.body.removeChild(script) } } CORS 跨域资源共享CORS：全称为 Cross-originresource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 Node 服务器端设置响应头示例代码： app.use((req, res, next) =&gt; { res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST&#39;); next(); }) withCredentials属性在使用Ajax技术发送跨域请求时，默认情况下不会在请求中携带cookie信息。 withCredentials：指定在涉及到跨域请求时，是否携带cookie信息，默认值为false Access-Control-Allow-Credentials：true 允许客户端发送请求时携带cookie","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"AJAX学习第二天","slug":"ajax2","date":"2019-12-19T12:31:55.000Z","updated":"2019-12-21T12:44:15.457Z","comments":true,"path":"2019/12/19/ajax2/","link":"","permalink":"/2019/12/19/ajax2/","excerpt":"","text":"今日目标 在浏览器中使用 art-template 完成省市区联动的案例 说出 FormData 的两个用法 完成文件上传和 进度展示 的案例 浏览器内使用 art-template回顾 ： 作用：把数据 和 html 字符串拼接在一起 用法： 1. 引入 template-web.js 文件 2. 准备 模板 `&lt;script type=&quot;text/html&quot; id=&quot;tpl&quot;&gt;&lt;/script&gt;` 3. 使用 template() 来渲染模板，第一个参数 ，模板 id, 第二个参数 ，传给模板 的数据 4. 把渲染的结果设置到容器中 省市区联动步骤： 准备html 结构， 引入 ajax.js bootstrap, art-template 展示省的数据 给省的 select 绑定 change ，请求并渲染市的数据 给市的 select 绑定 change 事件， 请求并渲染区的数据 当省的 数据 发生改变时，清空区的数据 &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;select class=&quot;form-control&quot; id=&quot;province&quot;&gt; &lt;!-- &lt;option&gt;请选择省份&lt;/option&gt; --&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;select class=&quot;form-control&quot; id=&quot;city&quot;&gt; &lt;option&gt;请选择城市&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;select class=&quot;form-control&quot; id=&quot;area&quot;&gt; &lt;option&gt;请选择县城&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/ajax.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/template-web.js&quot;&gt;&lt;/script&gt; &lt;!-- 省份模板 --&gt; &lt;script type=&quot;text/html&quot; id=&quot;provinceTpl&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择省份&lt;/option&gt; {{each province}} &lt;option value=&quot;{{$value.id}}&quot;&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;!-- 城市模板 --&gt; &lt;script type=&quot;text/html&quot; id=&quot;cityTpl&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择城市&lt;/option&gt; {{each city}} &lt;option value=&quot;{{$value.id}}&quot;&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;!-- 县城模板 --&gt; &lt;script type=&quot;text/html&quot; id=&quot;areaTpl&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择县城&lt;/option&gt; {{each area}} &lt;option value=&quot;{{$value.id}}&quot;&gt;{{$value.name}}&lt;/option&gt; {{/each}} &lt;/script&gt; &lt;script&gt; // 获取省市区下拉框元素 var province = document.getElementById(&#39;province&#39;); var city = document.getElementById(&#39;city&#39;); var area = document.getElementById(&#39;area&#39;); // 获取省份信息 ajax({ type:&#39;get&#39;, url:&#39;http://localhost:50003/province&#39;, success:function(data){ // console.log(data); // 将服务器端返回的数据和html进行拼接 var html = template(&#39;provinceTpl&#39;,{province:data}); // 将拼接好的html字符串显示在页面中 province.innerHTML = html; }, }); // 为省份的下拉框添加值改变事件 province.onchange = function(){ // 获取省份id var pid = this.value; // 清空县城下拉框中的数据 var html = template(&#39;areaTpl&#39;,{area:[]}) area.innerHTML = html; // 清空市区下拉框中的数据 var html = template(&#39;cityTpl&#39;,{city:[]}) city.innerHTML = html; if(pid == &quot;&quot;){ return; } // 根据省份id获取城市信息 ajax({ type:&#39;get&#39;, url:&#39;http://localhost:50003/cities&#39;, data:{ id:pid }, success:function(data){ // console.log(data); var html = template(&#39;cityTpl&#39;,{city:data}) city.innerHTML = html; }, }); }; // 当用户选择城市的时候 city.onchange = function(){ // 获取城市id var cid = this.value; // 根据城市id获取县城信息 ajax({ type:&#39;get&#39;, url:&#39;http://localhost:50003/areas&#39;, data:{ id:cid }, success:function(data){ // console.log(data); var html = template(&#39;areaTpl&#39;,{area:data}) area.innerHTML = html; }, }); }; &lt;/script&gt; FormData 用法一 用法一：收集表单中用户填写内容 提示：自已封装的ajax.js 暂时还不支持 传递 formdata 常用的实例方法： set 设置一个值 get 获取一个值 append 增加一个值 delete 删除一个值 用法二：实现文件的上传 先准备一个文件上传的控件 绑定一个change 事件 准备一个formdata , 然后调用 append(), 把用户选择的文件加到 formdata 中 再使用 xhr.send() 发送这个 formdata 文件上传的进度在上一步的基础上： 准备 进度条的代码，请查看 https://v3.bootcss.com/components/#progress 在.send() 方法调用 之前 增加 以下代码 来监听 进度事件 var bar = document.getElementById(&#39;bar&#39;); var bartext = document.getElementById(&#39;bartext&#39;); xhr.upload.onprogress = function(e) { var precent = parseInt(e.loaded / e.total * 100) + &#39;%&#39;; bar.style.width = precent; bartext.innerHTML = precent; }; 图片的预览功能步骤： 修改app.js 中的 upload 路由，让上传返回一个 path 路径 app.post(&quot;/upload&quot;, (req, res) =&gt; { // 创建formidable表单解析对象 const form = new formidable.IncomingForm(); form.uploadDir = path.join(__dirname, &quot;public&quot;, &quot;uploads&quot;); form.keepExtensions = true; // 解析客户端传递过来的FormData对象 form.parse(req, (err, fields, files) =&gt; { console.log(&quot;FIles--&gt;&quot;, files.attrName.path); var path = files.attrName.path.split(&quot;public&quot;)[1]; res.send({ path: path }); }); }); 在 js 代码中 ，取到这个 path 路径 ，创建图片， 设置 src 属性，监听图片的 onload 事件 xhr.onload = function() { if(xhr.status === 200) { var obj = JSON.parse(xhr.responseText); bar.classList.remove(&#39;active&#39;) var img = new Image(); img.src = obj.path; img.onload = function() { document.getElementById(&#39;container&#39;).appendChild(img) } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"AJAX学习第一天","slug":"ajax1","date":"2019-12-19T12:11:18.000Z","updated":"2019-12-21T12:45:17.789Z","comments":true,"path":"2019/12/19/ajax1/","link":"","permalink":"/2019/12/19/ajax1/","excerpt":"","text":"今日目标 了解AJAX 的使用场景 和 目的 了解 AJAX 的原理 学会使用 XHR 对象发送 get 请求 学会学会使用 XHR 对象发送 post 请求 知道常见的 ajax 错误状态码 封装 实现 Ajax 函数 （较难） Ajax的介绍 使用场景 搜索建议的功能 注册时校验用户名是否重复 页面的滚动加载数据 本质：在向服务端请求数据 目的：提升用户使用网站的体验， 等待时间更少，体验更好 使用Ajax 的步骤 创建异步请求对象 调用 open 方法 调用send 发送这个请求 接收响应的内容 // 1.创建ajax对象 var xhr = new XMLHttpRequest(); // 2.告诉Ajax对象要向哪发送请求，以什么方式发送请求 // 1)请求方式 2)请求地址 xhr.open(&#39;get&#39;, &#39;http://localhost:50003/first&#39;); // 3.发送请求 xhr.send(); // 4.获取服务器端响应到客户端的数据 xhr.onload = function (){ console.log(xhr.responseText) } 注意：服务器端需要配置相应的路由文件 // 引入express框架 const express = require(&#39;express&#39;); // 创建web服务器 const app = express(); app.get(&#39;/first&#39;,(req,res)=&gt;{ res.send(&#39;hellow,word&#39;) }) // 监听端口 app.listen(50003); // 控制台提示输出 console.log(&#39;服务器启动成功&#39;); 发请求的四个要素 请求方式 get post 请求的地址 URL 请求体 requestBody 请求头 requestHeader post 请求方式一 请求头：content-type: application/x-www-form-urlencoded 请求体： a=b&amp;b=c 使用这样的字符串 // 收集用户输入的参数 var userInput = document.getElementById(&#39;userName&#39;); var ageInput = document.getElementById(&#39;age&#39;); // 拼接参数 var params = `username=${userInput.value}&amp;age=${ageInput.value}` var xhr = new XMLHttpRequest(); // 请求的方式和地址 xhr.open(&#39;post&#39;, &#39;http://localhost:3000/post&#39;); // 设置请求头 xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;); // 设置请求体 xhr.send(params); xhr.onload = function() { console.log(); var obj = JSON.parse(xhr.responseText); console.log(obj) } post 请求方式二 请求头: application/json 请求体：JSON.stringify() // 收集用户输入的参数 var userInput = document.getElementById(&#39;userName&#39;); var ageInput = document.getElementById(&#39;age&#39;); // 拼接参数 var params = JSON.stringify({ username:userInput.value, age:ageInput.value }) var xhr = new XMLHttpRequest(); // 请求的方式和地址 xhr.open(&#39;post&#39;, &#39;http://localhost:3000/postjson&#39;); // 设置请求头 xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); // 设置请求体 xhr.send(params); xhr.onload = function() { var obj = JSON.parse(xhr.responseText); console.log(obj) } 旧的事件 onreadystatechange 在请求状态发生变化时，触发 readyState 的几个值 值 状态 说明 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。 3 LOADING 正在接收数据 4 DONE 请求结束 ，数据接收完成 错误处理的技术 网络连通的时候 400 提交的数据 有问题 404 请求地址写错了，自已的问题 500 后端的代码写错了，后端开发的问题 网络中断 网线断了，路由器关机 服务器关了 同步与异步 异步 代码，一般不关注函数的返回值，使用一个事件处理函数得到结果 同步 代码，一般会接收函数的返回值 Ajax 封装具体步骤： 基本功能：先定义一个 ajax 函数 ，传递一个对象进入，包含了 url, type, success 属性，发送一个 Get 请求，响应后调用 success 函数，并传递 响应结果 传递参数：在参数中加一个 data 选项，data 传一个对象进去，把对象转换成 &amp; 和 = 连接的字符串，如果 type 是 post , 就把参数入在 send 方法中，并使用 xhr.setRequestHeader 设置请求头，如果 type是 get 就放在 url 后面 传递json参数： 在参数中加一个 header 选项，选项中加上 content-type, 如果 为 application/json 就在内部 使用 JSON.stringy() 来处理 传递，再放在 send 方法中 处理错误：当状态码为 200 才调用成功的函数 ，否则才调用失败的 error 函数 处理响应：使用 xhr.getResponseHeader(‘Content-Type’) 方法，取到响应的类型，如果包含 application/json , 就使用 JSON.parse(xhr.responseText) 进行转换，再调用 success或 error 函数 优化参数：在函数内部 准备一个默认值，使用 Object.assign() 方法，把两个对象 合并 相关知识： 请回顾 实参 和 形参的知识 实参 调用函数时传递的参数， arguments 形参 定义函数时传递的参数 paramers 具体代码如下： function ajax(options) { var xhr = new XMLHttpRequest(); // 设置默认值 var defaults = { type:&#39;get&#39;, data: {}, url:&#39;&#39;, header: { &#39;Content-Type&#39; : &#39;application/json&#39; }, success: function() {}, error: function() {} }; // 用输入的值 覆盖 默认值 Object.assign(defaults, options) // 先做字符 串拼接 var params = &#39;&#39;; for(var i in options.data) { params += (i + &#39;=&#39; + options.data[i] + &#39;&amp;&#39;) } // 去掉最后一个 &amp; parans.substr(0, params.length -1) params = params.slice(0, -1); if(options.type === &#39;get&#39;) { xhr.open(options.type, options.url + &#39;?&#39; + params); } else { xhr.open(options.type, options.url); } if(options.type === &#39;post&#39;) { var contentType = options.header[&#39;Content-Type&#39;] xhr.setRequestHeader(&#39;Content-type&#39;, contentType); if(contentType === &#39;application/json&#39;) { xhr.send(JSON.stringify(options.data)) } else { xhr.send(params); } } else { xhr.send(); } xhr.onload = function() { var contentType = xhr.getResponseHeader(&#39;Content-Type&#39;); var responseText = xhr.responseText; if(contentType.includes(&#39;application/json&#39;)) { responseText = JSON.parse(responseText); } // 进一步判断 状态码 if(xhr.status === 200) { options.success(responseText); } else { options.error(responseText); } }; }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"资源下载","slug":"text2","date":"2019-10-27T08:05:48.000Z","updated":"2020-01-07T11:53:02.061Z","comments":true,"path":"2019/10/27/text2/","link":"","permalink":"/2019/10/27/text2/","excerpt":"","text":"提取链接：百度网盘提取码：2bbw提取链接：百度网盘提取码：ngqi","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"source","slug":"source","permalink":"/tags/source/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"GitHub+Hexo 个人博客搭建教程（一）","slug":"test","date":"2019-10-19T07:43:56.000Z","updated":"2019-11-19T05:57:19.260Z","comments":true,"path":"2019/10/19/test/","link":"","permalink":"/2019/10/19/test/","excerpt":"","text":"前言博客是一项被我误认为已经快消失殆尽的信息表达形式，简直是上一个时代的东西。自己对博客才有了一个全新的认识，好记性不如烂键盘，博客可以详细的记载下在学习过程中遇到的那些扎心知识点和自己对其的见解。并且可以展示出来，这样假如有错误也能够最快程度的发现。因此萌生了一个自己建一个博客的想法。 目前市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。 而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。 那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。 经过一段时间的收集资料，发现有另外几种方案的实现，Wordpress, Hexo, Jekyll等， 既减少了服务器上的运维，也可以拥有好看的前端效果，而且整个搭建过程也是很简单的。 采用Hexo博客框架，来快速搭建属于自己的博客系统，在托管到Pages上去，可以省去服务器维护的时间和精力。Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo的主题样式也有很多好看的，而且github都有star上万的。说明还是很受欢迎的。 hexo介绍Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 hexo的搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。 windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 2. node.jsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。windows：nodejs选择LTS版本就行了。安装完后，打开命令行。检查一下有没有安装成功顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用(我不太会用）。 node -v npm -v 3. 安装hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 敲出下面命令来下载hexo npm install -g hexo-cli 初始化 hexo init myblog 初始化完成后，目标文件夹下目录 node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 生成静态文件 hexo g 启动服务器。默认情况下，访问网址为： http://localhost:4000/。(使用ctrl+c可以把服务关掉) hexo s 4. GitHub创建个人仓库首先需要创建一个github的账号。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建完成后，点击GitHub中的New repository创建新仓库，仓库名应该为：用户名.http://github.io 这个用户名使用你的GitHub帐号名称代替，这是固定写法。 5. 生成SSH添加到GitHub回到你的git bash中， 输入以下命令，这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 然后创建SSH ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 将公钥添加到GitHub上 详细教程请百度搜索 点击用户头像-&gt;settings-&gt;SSH and GPG keys -&gt;New SSH key 将id_rsa.pub中的内容复制到key-&gt;文本框中，然后点击Add SSH key(添加SSH)按钮 Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。在Git Bash中检测GitHub公钥设置是否成功，输入 ： ssh -T git@github.com 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户名称 deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后输入以下命令 hexo clean hexo generate hexo deploy hexo clean 清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 在输入 hexo deploy 时可能弹出对话框要你输入username和password。 到这一步为止，你的网站已成功部署到github上了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-08-31T21:07:44.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}